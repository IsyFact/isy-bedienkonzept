= Baustein Bedienkonzept

include::glossary:licence:partial$licence.adoc[]

[[einfuehrung]]
== Einführung

Das vorliegende Bedienkonzept ist nicht nur ein Dokument mit Gestaltungsrichtlinien für xref:4.0.0@isyfact-standards-doku:referenzarchitektur:software-technisch/frontend.adoc[Frontends], sondern ein umfassendes Werkzeug, das die Grundlage für die Entwicklung einer konsistenten und benutzerfreundlichen Benutzeroberfläche schafft.
Indem es einheitliche Standards und Best Practices festlegt, trägt es maßgeblich zur Erreichung von Zielen wie der Steigerung der Benutzerzufriedenheit, der Verbesserung der Effizienz oder der Stärkung der Markenidentität bei.

Das Hauptziel ist dabei, die Benutzererfahrung zu verbessern und die Zufriedenheit und Produktivität der Nutzenden zu maximieren.
So soll sichergestellt werden, dass Nutzende das Frontend ohne Schwierigkeiten verwenden können und dabei ihre Ziele *effizient* erreichen.

In den folgenden Kapiteln werden die benötigten Elemente von "klein nach groß" beschrieben.
*Der allgemeine Rahmen und die übergreifenden Prinzipien* werden in den ersten Kapiteln beschrieben.
Darauf folgen die *<<basiselemente>>* (wie zum Beispiel <<text>> und <<farben>>), die den Grundstein für die nachfolgenden Kapitel legen und von essenzieller Bedeutung sind.
Danach kommen die *<<bedienelemente>>*, die einfachste Ausprägung eines Interaktionselements.
*<<design-pattern>>* stellen eine Bündelung von Bedienelementen und Basiselementen dar und können letztendlich in beliebiger Kombination als vollständige *<<use-cases>>* beschrieben werden.

Es ist eine xref:referenzimplementierung.adoc[Referenzimplementierung ("Live-Demo")] zu den Richtlinien dieses Bedienkonzepts verfügbar.

[[einfuehrung-in-das-bedienkonzept]]
=== Einführung in das Bedienkonzept

*_Gültigkeit und Anwendung_*

Dieses Konzept ist für jedes Frontend relevant, unabhängig von dessen Komplexität oder Zielgruppe.
Es ist gültig für alle Neuentwicklungen und für Überarbeitungen von Frontends, die einem Major Change oder Technologiewechsel unterliegen.

IMPORTANT: Ausgeschlossen sind minimale Bugfixes und die grundsätzliche Wartung von Bestandsanwendungen.
Für diese Fälle bleibt das xref:3.2.1@isyfact-standards-doku:isy-bedienkonzept:bedienkonzept.adoc[alte Bedienkonzept (ehemals Styleguide)] mit den damals geltenden Inhalten gültig.

*_Rolle von Designenden, Entwickelnden und Fachlichkeit_*

Designende und Entwickelnde spielen eine entscheidende Rolle bei der Umsetzung des Bedienkonzepts.
Während Designende für die Gestaltung der Benutzeroberfläche verantwortlich sind und sicherstellen, dass sie den festgelegten Standards entspricht, liegt es in der Verantwortung der Entwickelnden, diese Gestaltung in einem funktionierenden Frontend umzusetzen.
Eine enge Zusammenarbeit zwischen Design- und Entwicklungsteams ist unerlässlich, um sicherzustellen, dass das Endprodukt den gestalterischen und funktionalen Anforderungen entspricht.
Insbesondere bei komplexen Frontends ist es ratsam so früh wie möglich die Fachlichkeit hinzuzuziehen und den erarbeiteten Stand der Konzeption zu evaluieren.

*_Einhaltung von Standards und Best Practices_*

Das Bedienkonzept legt Standards und Best Practices fest, die von Designenden und Entwickelnden eingehalten werden müssen.
Diese Standards können sich auf verschiedene Aspekte der Gestaltung und Interaktion beziehen, wie Typografie, <<farben,Farbgebung>>, <<bedienelemente>> und <<barrierefreiheit>>.
Durch die Einhaltung dieser Standards gewährleisten Designende und Entwickelnde nicht nur eine konsistente Benutzeroberfläche, sondern auch die Kompatibilität dieser Oberfläche mit verschiedenen Geräten und Plattformen.

Genau wie jedes digitale Frontend wird auch dieses Bedienkonzept ständig weiterentwickelt.
Die Entwicklungen und Änderungen werden entsprechend dem Stand der Technik und der rechtlichen Gegebenheiten aktualisiert und gekennzeichnet.

*_Technische Kompatibilität_*

Wenn Frontends anhand dieses Bedienkonzepts erstellt werden, müssen die korrekte Darstellung und Funktionsweisen des Frontends inklusive ihrer Browser-Funktionen, wie beispielsweise "Vor" und "Zurück", geprüft werden.
Dafür muss für jedes Projekt der primäre Browser und dessen Versionen ermittelt und geprüft werden.

In der Regel soll sichergestellt sein, dass folgende Browser unterstützt werden:

|===
|Browser |Neuste Version aus Channel

|Microsoft Edge
|Stable Channel

|Firefox
|ESR

|Chrome
|Stable Channel
|===

Soweit notwendig wird auf browser-spezifische Eigenheiten eingegangen.
Dabei sind folgende Auflösungen zu berücksichtigen:

// ToDo: Notwendigen Auflösungen sollten noch diskutiert und entsprechend angepasst werden!
* *2K:* 2560 x 1440
* *Full HD:* 1920 x 1080
* *Tablet:* 1536 x 864
* *Smartphone:* 390 x 873

*_Kontinuierliche Weiterentwicklung und Pflege_*

Ein Bedienkonzept ist kein statisches Dokument, sondern sollte kontinuierlich weiterentwickelt und gepflegt werden.
Mit dem Fortschreiten der Technologie und den sich ändernden Anforderungen der Nutzenden ist es wichtig, das Bedienkonzept regelmäßig zu überprüfen und anzupassen.
Dadurch wird sichergestellt, dass das Bedienkonzept stets den aktuellen Standards und Best Practices entspricht.
Diese kontinuierliche Weiterentwicklung erfordert eine enge Zusammenarbeit zwischen allen Beteiligten und eine offene Kommunikation über Änderungen und Aktualisierungen – insbesondere zwischen Umsetzungsprojekten, Stakeholdern und den Designenden, die mit diesem Dokument arbeiten.

[[usability-und-benutzerfreundlichkeit]]
=== Usability (UI) und Benutzerfreundlichkeit (UX)

Obwohl die Begriffe oft synonym verwendet werden, gibt es wichtige Unterschiede und Zusammenhänge, die sie voneinander unterscheiden und gleichzeitig miteinander verbinden.

*_Begriff der Usability (User Interface - UI)_*

Usability oder Gebrauchstauglichkeit bezieht sich auf die Benutzerfreundlichkeit einer Oberfläche (UI).
Dabei geht es darum, wie leicht Nutzende ein Frontend verstehen und die Bedienung erlernen können.
Zu den Hauptkomponenten der Usability gehören:

* *Effektivität:*
Die Fähigkeit eines Frontends, den Nutzenden die Möglichkeit zu geben, ihre Ziele zu erreichen.
* *Effizienz:*
Die Fähigkeit eines Frontends den Nutzenden zu ermöglichen, ihre Ziele mit möglichst geringem Zeit- und Arbeitsaufwand zu erreichen.
* *Zufriedenheit:*
Das Maß an Komfort und positiver Erfahrung der Benutzenden bei der Nutzung des Frontends.

Usability ist eng mit dem Design der Benutzeroberfläche verknüpft.
Eine gut gestaltete UI ermöglicht es den Benutzenden, intuitiv zu navigieren, schnell zu verstehen, wie sie Aufgaben ausführen können und bietet klare, konsistente visuelle Hinweise.
Besonders bei komplexen Fachanwendungen ist es wichtig, dass eine gute UI sich nahtlos in die fachlich notwendigen Geschäftsprozesse integrieren lässt.

*_Begriff der Benutzerfreundlichkeit (User Experience - UX)_*

Benutzerfreundlichkeit oder User Experience (UX) geht über die reine Usability hinaus und bezieht sich auf das gesamte Erlebnis der Nutzenden mit einem Produkt oder einer Dienstleistung.
UX umfasst alle Aspekte der Interaktion, einschließlich der emotionalen, psychologischen und praktischen Reaktionen auf das Produkt.

*Hauptkomponenten der UX sind:*

* *Nützlichkeit:*
Ob das Produkt den Bedürfnissen und Anforderungen der Benutzenden entspricht.
* *Verfügbarkeit:*
Die Zugänglichkeit und Erreichbarkeit des Produkts für verschiedene Gruppen.
* *Glaubwürdigkeit:*
Das Vertrauen der Benutzenden in das Produkt und die Marke.
* *Wert:*
Die Wahrnehmung des Nutzens und der Wertschöpfung durch das Produkt.

UX berücksichtigt nicht nur die Interaktion mit der Benutzeroberfläche, sondern auch die gesamte Benutzerreise von der ersten Wahrnehmung des Produkts bis zur fortlaufenden Nutzung und Unterstützung.

*_Zusammenhänge zwischen Usability (UI) und Benutzerfreundlichkeit (UX)_*

Usability ist ein integraler Bestandteil der Benutzerfreundlichkeit.
Ein benutzerfreundliches Frontend muss eine hohe Usability aufweisen, da die Benutzeroberfläche der primäre Kontaktpunkt zwischen den Benutzenden und dem Frontend ist.
Gute Usability sorgt für:

* *Reibungslose und intuitive Interaktion:*
Benutzende können problemlos navigieren und ihre Ziele erreichen, was zu einer positiven UX beiträgt.
* *Effizienz:*
Benutzende brauchen weniger Zeit und Mühe, um Aufgaben zu erledigen, was ihre Zufriedenheit erhöht und die Gesamt-UX verbessert.

*_Unterschiede zwischen Usability (UI) und Benutzerfreundlichkeit (UX)_*

Trotz ihrer engen Verbindung gibt es klare Unterschiede zwischen UI und UX:

* *Fokusbereich:*
Usability konzentriert sich auf die Effizienz und Effektivität der Benutzeroberfläche, während UX das gesamte Erlebnis der Nutzenden mit dem Produkt betrachtet.
* *Umfang:*
Usability befasst sich hauptsächlich mit den funktionalen Aspekten der Interaktion wie Navigation und Bedienbarkeit, während UX auch emotionale und psychologische Faktoren einbezieht wie Freude und Zufriedenheit.
* *Messbarkeit:*
Usability kann durch spezifische Metriken wie Fehlerquote, Zeitaufwand und Benutzerzufriedenheit gemessen werden.
UX erfordert jedoch eine umfassendere Bewertung, die qualitative und quantitative Methoden kombiniert, um das gesamte Benutzererlebnis zu verstehen.

*_Grundlegende Dos, die die Benutzerfreundlichkeit einer Benutzeroberfläche in Frontends erhöhen:_*

* *Klare Anweisungen und Fehlermeldungen:*
Nutzende sollten stets verstehen, was von ihnen erwartet wird.
Klare Anweisungen und verständliche Fehlermeldungen helfen dabei, Frustration zu vermeiden und den Nutzenden durch den Prozess zu führen.
* *Validierung von Eingaben:*
Eingabefelder sollten in Echtzeit validiert werden, um Nutzende vor Fehlern zu warnen, bevor sie das Formular absenden.
Dadurch wird vermieden, dass Nutzende nach dem Absenden des Formulars feststellen, dass sie fehlerhafte oder unvollständige Informationen eingegeben haben.
* *Progressive Offenbarung von Informationen:*
Die Benutzeroberfläche sollte nicht mit zu vielen Informationen auf einmal überladen werden.
Informationen sollten kontextbezogen und schrittweise offenbart werden, um Nutzende nicht zu überfordern.
* *Testen mit verschiedenen Nutzungsgruppen:*
Um sicherzustellen, dass die Oberfläche für eine breite Palette von Nutzenden zugänglich ist, ist es wichtig, Tests mit verschiedenen Personengruppen durchzuführen.
Dabei sollten Nutzende mit unterschiedlichen Fähigkeiten, Geräten und technischen Kenntnissen berücksichtigt werden.

Weitere Informationen zu einer besseren Benutzerfreundlichkeit sind in den Abschnitten zu den <<basiselemente,Basiselementen>>, <<bedienelemente,Bedienelementen>>, <<design-pattern>>, <<use-cases>> oder <<eingabehilfen-und-fehlermeldungen>> zu finden (siehe jeweils bei den Unterkapiteln "Dos and Don'ts").

[[allgemeine-prinzipien]]
=== Allgemeine Prinzipien

Das Bedienkonzept basiert auf einer Reihe von allgemeinen Prinzipien, die als Leitfaden für die Gestaltung von Benutzeroberflächen dienen.
Diese Prinzipien umfassen Klarheit, Konsistenz, Feedback, Effizienz und Zugänglichkeit und bilden das Fundament für eine benutzerzentrierte Gestaltung.
Viele dieser Prinzipien werden beispielsweise in der https://de.wikipedia.org/wiki/ISO_9241[ISO 9241] und in https://en.wikipedia.org/wiki/Web_usability#Web_Usability_Criteria[Nielsen’s Web Usability Criteria] beschrieben.
Zusätzlich liefert https://lawsofux.com/[lawsofux] eine anschauliche Sammlung von *Designprinzipien*.

*_Klarheit_*

In Bezug auf das Design bezieht sich das Prinzip der "Klarheit" darauf, wie verständlich und einfach der Aufbau und die Navigation des Frontends gestaltet sind.
Klarheit bedeutet, dass Informationen klar präsentiert werden, sodass Besuchende sofort verstehen, was das Frontend bietet und wie sie es nutzen können.
Dies umfasst eine klare Strukturierung von Inhalten, eine leicht lesbare Typografie, gut platzierte Navigationselemente und eine konsistente visuelle Gestaltung.
Durch die Priorisierung von Klarheit im Design können Designende sicherstellen, dass Nutzende sich leicht auf dem Frontend zurechtfinden und ihre Ziele effizient erreichen können.

*_Konsistenz_*

Das Prinzip der "Konsistenz" bezieht sich auf die Notwendigkeit, ein einheitliches Erscheinungsbild und Verhalten über alle Seiten eines Frontends hinweg zu gewährleisten.
Konsistenz bedeutet, dass Designelemente wie <<farben>>, <<text,Schriftarten>>, <<icons,Symbole>> und Layouts einheitlich angewendet werden, um eine nahtlose Benutzererfahrung zu schaffen.
Durch die Aufrechterhaltung einer konsistenten Gestaltung können Nutzende das Frontend leichter verstehen und navigieren, da sie sich auf bereits bekannte Muster und Interaktionen verlassen können.
Darüber hinaus trägt die Konsistenz dazu bei, das Markenimage zu stärken und das Vertrauen der Nutzenden in das Frontend zu fördern.

*_Feedback_*

Das Designprinzip des "Feedbacks" bezieht sich auf die kontinuierliche Kommunikation zwischen dem Frontend und den Nutzenden.
Feedback ist entscheidend, um den Nutzenden Rückmeldungen darüber zu geben, ob ihre Aktionen erfolgreich waren oder nicht.
Dies kann in Form von visuellem Feedback, zum Beispiel einer Farbänderung eines <<button,Buttons>> nach einem Klick oder durch informative Nachrichten wie Bestätigungsmeldungen nach dem Absenden eines <<formulare,Formulars>>, erfolgen.
Durch effektives Feedback fühlen sich Nutzende unterstützt und informiert, was zu einer verbesserten Benutzererfahrung und einer höheren Zufriedenheit führt.
Dies gilt insbesondere auch für Aspekte der <<barrierefreiheit>>.
Technische Standardmöglichkeiten sollen genutzt und gegebenenfalls mit entsprechenden Hilfsmitteln (wie <<aria-labels,ARIA-Elementen>>) angereichert werden.

*_Effizienz_*

Das Designprinzip der "Effizienz" bezieht sich darauf, wie gut ein Frontend die Bedürfnisse und Ziele der Nutzenden mit minimalen Aufwänden erfüllt.
Effizientes Design strebt danach, unnötige Komplexität zu vermeiden und die Interaktionen der Nutzenden so reibungslos wie möglich zu gestalten.
Dies umfasst Aspekte wie schnelle Ladezeiten, intuitive Navigation, gut platzierte Call-to-Actions und eine klare Informationsarchitektur.
Ein effizientes Design stellt sicher, dass Nutzende ihre Ziele schnell erreichen können, ohne dabei Zeit oder Mühe zu verschwenden – sei es beim Finden von Informationen, beim Abschließen eines Kaufs oder beim Ausführen einer bestimmten Aktion.

*_Zugänglichkeit_*

Das Designprinzip der "Zugänglichkeit" soll sicherstellen, dass ein Frontend für alle Nutzenden, unabhängig von ihren individuellen Fähigkeiten oder Einschränkungen, leicht zugänglich ist.
Dies beinhaltet die Gestaltung und Entwicklung des Frontends unter Berücksichtigung verschiedener Bedürfnisse, zum Beispiel Sehbehinderungen, Hörbehinderungen oder motorische Einschränkungen.
Zugängliches Design beinhaltet die Verwendung von verständlichen <<text,Texten>>, von <<barrierefreier-einsatz-von-farben,ausreichendem Kontrast zwischen Text und Hintergrund>>, von Tastaturzugänglichkeit und von <<alt-tag,alternativen Texten für Bilder>>, sowie die Vermeidung von Technologien (zum Beispiel Gestensteuerung), die für einige Personengruppen hinderlich sein könnten.
Ein zugängliches Design gewährleistet, dass alle Nutzenden die Informationen und Funktionen des Frontends nutzen können, was zu einer inklusiven und positiven Benutzererfahrung führt.
Dieses Prinzip wird im Kapitel <<barrierefreiheit>> und unter den einzelnen <<bedienelemente,Bedienelementen>> detaillierter beschrieben.

[[barrierefreiheit]]
== Barrierefreiheit

Barrierefreiheit setzt das Prinzip der Zugänglichkeit um.
Das heißt durch Barrierefreiheit soll sichergestellt werden, dass alle, unabhängig von ihren Fähigkeiten, ein Frontend nutzen können.
Im Folgenden werden die Richtlinien zur Barrierefreiheit gemäß Standards wie WCAG und Methoden zur Verbesserung der Zugänglichkeit erläutert.

Für dieses Bedienkonzept gilt, dass die Zugänglichkeitsstandards WCAG 2.1 und EN 305419 berücksichtigt werden müssen:

* Alle Seiten sollten mindestens das Level AA oder höher erreichen.
* Für Haupt- & Einstiegsseiten und Seiten mit rechtlicher Relevanz sollte das Level AAA berücksichtigt werden.

Die detaillierten Anforderungen sind zu finden unter:

* https://www.w3.org/TR/WCAG21/[WCAG 2.1]
* https://www.barrierefreiheit-dienstekonsolidierung.bund.de/Webs/PB/DE/gesetze-und-richtlinien/en301549/en301549-node.html[EN 305419]

Vor der Auflistung der einzelnen Kriterien sind im Kontext der IsyFact einige Kriterien der Barrierefreiheit besonders herauszustellen und bereits bei der fachlichen Konzeption zu berücksichtigen.
In der Regel sind die genannten Anforderungen durch die Nutzung der Standardelemente der IsyFact erfüllt oder es wird die Möglichkeit geboten, zum Beispiel durch das Theme, diese in einem Frontend umzusetzen.
Alle hier genannten Maßnahmen sind besonders hervorzuheben und unabdinglich für ein barrierefreies Frontend.

*Dos*

* <<eingabefeld,Eingabefelder>> müssen nach der Aktivierung eines Hochkontrastmodus/Farbfilters zu 50 % bestehen bleiben – eine einzelne Linie als Bestandteil ist nicht ausreichend als Identifizierung eines Eingabefeldes.
* Die Textgröße soll zum Erreichen der AA-Kriterien mindestens 14pt für Labels und 12pt für Fließtexte betragen.
* Der Textkontrast muss immer mindestens 4,5:1 und bei großer Schrift mindestens 3:1 betragen.
Für Haupt- und Einstiegsseiten sowie Seiten mit rechtlicher Relevanz muss der Kontrast 7:1 betragen.
* Alle Bilder benötigen ein inhaltlich sinnvolles, beschreibendes <<alt-tag,Alt-Attribut>>.
* <<grafiken,Bilder>>, die ausschließlich der Gestaltung dienen (zum Beispiel Trennlinien), müssen als solche (Schmuckgrafik) gekennzeichnet werden.
* *Tastatur-Navigation:*
Nicht alle Nutzenden können eine Maus verwenden.
Daher ist es wichtig, dass alle Interaktionen auf dem Frontend auch über die Tastatur möglich sind.
Dies bedeutet, dass alle Navigationselemente, <<link,Links>> und interaktiven Elemente leicht per Tastatur zugänglich sein müssen.

*Don'ts*

* Es sollten keine Schriftgrafiken genutzt werden.
* Schwache Kontraste, zum Beispiel Hellblau auf Grau, sollen vermieden werden.
* *Vermeidung von reinen Farbunterscheidungen:*
Informationen sollten nicht allein durch <<farben,Farbe>> vermittelt werden, da einige Nutzende Farben nicht unterscheiden können.
Daher sollten auch andere visuelle Elemente, wie <<icons,Symbole>> oder Muster genutzt werden, um wichtige Informationen zu vermitteln.
* Aktionen sollen nicht durch <<bedienelemente>> ausgelöst werden, wenn diese nicht dazu vorgesehen sind (zum Beispiel <<radiobutton>> und <<checkbox,Checkboxen>>).

[[tastatursteuerung]]
=== Tastaturbedienbarkeit und Tastaturkombinationen

Die Tastatursteuerung ist eine elementare Art der Navigation für Frontends.
Wichtig ist dabei die Einhaltung standardisierter Bedienmuster, um eine intuitive und konfliktfreie Nutzung zu gewährleisten.
Anwendungen der IsyFact nutzen daher die bekannten Standardkombinationen, verzichten somit auf eigene Tastenkombinationen und bilden so die Basis für eine einheitliche und barrierefreie Bedienung.
Beispiele hierfür sind:

* *Tabulator:* Navigation zwischen interaktiven Elementen wie <<link,Links>>, <<button,Buttons>> oder <<eingabefeld,Eingabefeldern>>.
* *Shift + Tab:* Navigation rückwärts zwischen interaktiven Elementen.
* *Enter:* Aktivierung von Buttons, <<link,Links>> und anderen interaktiven Elementen.
* *Leertaste:* Scrollen in Seiten (bei nicht fokussierten Elementen) oder Aktivieren von <<checkbox,Checkboxen>> (bei fokussierten Checkboxen).
* *Pfeiltasten:* Navigation in <<liste,Listen>>, <<dropdown,Dropdowns>> oder <<textbox,Textfeldern>>.
* *Esc:* Schließen von Dialogen oder Dropdowns.

Der reine Einsatz von Standardkombinationen in der Tastatursteuerung ist nicht ausreichend, eine größtmögliche <<barrierefreiheit,Barrierefreiheit>> sicherzustellen.
So gibt es noch weitere "Dos and Don'ts" im Rahmen der Tastatursteuerung zu beachten:

*_Dos_*

* *Fokussteuerung:* Alle interaktiven Elemente müssen in einer logischen Reihenfolge fokussierbar sein, ohne unerwartete Wechsel oder Sprünge.
* *Tastaturzugänglichkeit:* Dynamische Elemente wie Dropdowns, Dialoge oder modale Fenster sind vollständig mit der Tastatur bedienbar.
* *Feedback:* <<fehlermeldungen>> und Erfolgshinweise werden sowohl visuell als auch über Screenreader wahrnehmbar angezeigt.
* *Standardbedienmuster:* Es werden nur Standard-Tastenkombinationen verwendet, um Konflikte mit Browserfunktionen oder Assistenzsoftware zu vermeiden.

*_Don'ts_*

* *Eingeschränkte Zugänglichkeit:* Kein interaktives Element darf ausschließlich mit der Maus bedienbar sein.
* *Unklare Zustände:* Elemente wie Buttons oder Links dürfen keinen unklaren oder schwer erkennbaren Fokuszustand haben.
* *Unübersichtliche Navigation:* Eine übermäßige Anzahl von Tab-Stops oder unlogische Fokuswechsel müssen vermieden werden.

Unter Beachtung der oben genannten Richtlinien ist eine effiziente und klare Bedienung möglich.
Weitere Kombinationen im Browser zur Steigerung der Effektivität sind (Abweichungen möglich):

*_Navigation und grundlegende Aktionen_*

. Strg + L / Cmd + L: Fokus auf die Adressleiste.
. Strg + T / Cmd + T: Öffnen eines neuen Tabs.
. Strg + W / Cmd + W: Schließen des aktuellen Tabs.
. Strg + Tab / Cmd + Tab: Wechseln zum nächsten Tab.
. Strg + Shift + Tab / Cmd + Shift + Tab: Wechseln zum vorherigen Tab.
. Strg + R / Cmd + R: Neuladen der aktuellen Seite.
. Alt + Pfeil nach links: Zurück zur vorherigen Seite.
. Alt + Pfeil nach rechts: Vorwärts zur nächsten Seite.
. F5: Neuladen der Seite.
. Shift + F5: Erzwungenes Neuladen (ohne Cache).

*_Textbearbeitung und Eingabe_*

. Strg + A / Cmd + A: Gesamten Text auswählen.
. Strg + C / Cmd + C: Kopieren des ausgewählten Textes.
. Strg + V / Cmd + V: Einfügen aus der Zwischenablage.
. Strg + X / Cmd + X: Ausschneiden des ausgewählten Textes.
. Strg + Z / Cmd + Z: Rückgängig machen der letzten Aktion.
. Strg + Y / Cmd + Shift + Z: Zurückholen der zuletzt rückgängig gemachten Aktion.
. Strg + F / Cmd + F: Öffnen der Suchfunktion.
. F3: Weiter zur nächsten Suchergebnismarkierung springen.
. Strg + P / Cmd + P: Öffnen des Druckdialogs.
. Tab: Wechsel zwischen Formularfeldern oder interaktiven Elementen.
. Shift + Enter: Absenden eines Formulars (bei ausgewählten Textfeldern oder Buttons).

*_Zoom und Anzeige_*

. Strg + Plus (pass:[+]) / Cmd + Plus (pass:[+]): Vergrößern des Seiteninhalts.
. Strg + Minus (-) / Cmd + Minus (-): Verkleinern des Seiteninhalts.
. Strg + 0 / Cmd + 0: Zurücksetzen des Zooms auf die Standardgröße.
. F11: Umschalten in den Vollbildmodus.

*_Bedienung mit Screenreadern_*

. Tab: Navigieren zwischen Fokusbereichen.
. Shift + Tab: Rückwärts navigieren zwischen Fokusbereichen.
. Pfeil nach unten / oben: Zeilenweises Navigieren in Listen und Text.
. Strg + Pfeil nach rechts / links: Springen zwischen Wörtern in Textfeldern.
. Alt + Shift + Pfeil nach unten / oben: Navigieren zwischen Absätzen.

Diese Kombinationen ergänzen die grundlegenden Funktionen und gewährleisten eine nahtlose Integration mit Browser-Standards und assistiven Technologien wie Screenreadern.
Die Einhaltung dieser Standards ermöglicht eine barrierefreie und effiziente Navigation für alle Nutzergruppen.


[[barrierefreier-einsatz-von-farben]]
=== Barrierefreier Einsatz von Farben

<<farben>> sind ein Hauptbestandteil, um Frontends zu gestalten und um die Nutzenden zu unterstützen.
Um eine gute Erkennbarkeit der Elemente sicherzustellen, muss bei großer Schrift ein Kontrast von mindestens 3:1 gewährleistet sein.

Nachfolgend sind die Kontrastverhältnisse aller zur Verfügung stehenden Farben abgebildet.
Farbkombinationen, die rot gelabelt sind und keinen ausreichenden Kontrast aufweisen, dürfen nicht verwendet werden.
Andere Farbkombinationen sind entsprechend ihrer Textart oder Elementgröße frei zu wählen - Fließtext & Label 4,5:1, Überschrift 3:1, Haupt-/Einstiegsseiten & Seiten mit rechtlicher Relevanz 7:1.
Dabei soll der Kontrast so hoch wie möglich gewählt werden.

[[image-farbmatrix]]
.Farbmatrix
image::24_BE_colormatrix.png[align="center"]

Eine interaktive und erweiterbare Tabelle ist unter link:++https://contrast-grid.eightshapes.com/?version=1.1.0&background-colors=&foreground-colors=%23000000%2C%20Black%0D%0A%23FFFFFF%2C%20White%0D%0A%23F2F2F2%2C%20light%20Grey%0D%0A%23DDDDDD%2C%20Grey%0D%0A%2383878c%2C%20medium%20Grey%0D%0A%23404040%2C%20Charcoal%0D%0A%23212529%2C%20dark%20Grey%0D%0A%230055B9%2C%20Active%20and%20Primary%0D%0A%2366AEE5%2C%20Primary%20disabled%0D%0A%23D45C00%2C%20Secondary%0D%0A%23A4252C%2C%20Alert%0D%0A%23498205%2C%20Success%0D%0A%23D47D00%2C%20Warning%0D%0A%23008EDB%2C%20Info%0D%0A%238378DE%2C%20Help%0D%0A%0D%0A%0D%0A%0D%0A%0D%0A%0D%0A&es-color-form__tile-size=regular&es-color-form__show-contrast=aaa&es-color-form__show-contrast=aa&es-color-form__show-contrast=aa18&es-color-form__show-contrast=dnp++[Farbmatrix] zu finden.

Die folgenden Links verweisen auf weitere Informationen zur Kontrast-Analyse:

* http://whocanuse.com[WhoCanUse?]
* http://leserlich.info/kapitel/farben.php[leserlich.info]

[[alt-tag]]
=== Alt-Attribute für Bilder

Alt-Attribute (alternative Texte) sind textuelle Beschreibungen, die in den HTML-Code von <<grafiken,Bildern>> eingebettet werden.
Sie dienen mehreren wichtigen Zwecken:

* *Zugänglichkeit:*
Screenreader verwenden Alt-Attribute, um sehbehinderten oder blinden Nutzenden den Inhalt und Zweck eines Bildes zu vermitteln.
* *Fehlertoleranz:*
Wenn ein Bild aus irgendeinem Grund nicht geladen werden kann, zeigt der Browser den Alt-Text anstelle des Bildes an.

*_Best Practices für das Schreiben von Alt-Attributen_*

Beim Erstellen von Alt-Texten sollten folgende Richtlinien beachtet werden:

* *Beschreibend und prägnant:*
Der Alt-Text sollte den Inhalt und Zweck des Bildes kurz und genau beschreiben.
Beispiel:
[source,xml]
<img src="blume.jpg" alt="Gelbe Tulpe im Frühlingsgarten">.

* *Kontextbezogen:*
Der Alt-Text sollte den Kontext berücksichtigen, in dem das Bild verwendet wird.
Beispiel:
Bei einem Bild eines Einkaufswagens auf einer E-Commerce-Seite könnte der Alt-Text lauten:
[source,xml]
<img src="cart.png" alt="Warenkorb">.

* *Keine redundante Information:*
Informationen, die bereits im umgebenden Text enthalten sind, müssen nicht im Alt-Text wiederholt werden.
Beispiel:
Wenn ein Bild neben einer <<ueberschriften,Überschrift>> „Teamfoto 2024“ steht, sollte der Alt-Text nicht einfach „Teamfoto 2024“ wiederholen.
* *Vermeidung von Keyword-Stuffing:*
Der Alt-Text sollte nicht mit Schlüsselwörtern überladen werden, da dies die Zugänglichkeit beeinträchtigt.
* *Verwendung von leeren Alt-Attributen für dekorative Bilder:*
Wenn ein Bild rein dekorativ ist und keinen informativen Wert hat, sollte das Alt-Attribut leer sein (alt=""), um Screenreadern zu signalisieren, dass sie das Bild ignorieren können.

[[aria-labels]]
=== ARIA-Labels für andere Bedienelemente

*_Bedeutung von ARIA-Labels:_*

ARIA-Labels (Accessible Rich Internet Applications) sind ein Set von Attributen, die entwickelt wurden, um die Zugänglichkeit von dynamischen Inhalten und Benutzeroberflächen zu verbessern.
Sie bieten zusätzliche Informationen für Screenreader, insbesondere für Elemente, die keine standardisierten HTML-Attribute zur Beschreibung ihres Zwecks haben.

*_Implementierung von ARIA-Labels:_*

ARIA-Labels kommen zum Einsatz, wenn ein <<bedienelemente,Bedienelement>> keinen eindeutigen für Screenreader zugänglichen Text enthält.
Hier sind die wichtigsten ARIA-Attribute und ihre Anwendungen:

* *aria-label:*
Wird verwendet, um ein Element zu beschreiben.
Es ist besonders nützlich für Bedienelemente ohne sichtbaren Text.
Beispiel:
[source,xml]
<button aria-label="Schließen">X</button>.

* *aria-labelledby:*
Verweist auf ein anderes Element, dessen Text als Beschriftung dient.
Beispiel:
[source,xml]
<button aria-labelledby="closeButtonText">X</button>
<span id="closeButtonText" hidden>Schließen</span>.

* *aria-describedby:*
Gibt ein anderes Element an, das eine ausführlichere Beschreibung des aktuellen Elements enthält.
Beispiel:
[source,xml]
<input type="text" aria-describedby="nameDesc">
<span id="nameDesc">Bitte geben Sie Ihren vollständigen Namen ein.</span>.

*_Best Practices für die Verwendung von ARIA-Labels_*

Um sicherzustellen, dass ARIA-Labels effektiv eingesetzt werden, sollten folgende Richtlinien beachtet werden:

* *Klarheit und Präzision:*
ARIA-Labels sollten klar und präzise sein, um den Zweck des Elements genau zu vermitteln.
* *Vermeidung von Redundanz:*
ARIA-Labels sollten nicht redundant zu bereits vorhandenen textuellen Beschreibungen sein.
* *Konsistenz:*
Die Verwendung von ARIA-Labels sollte konsistent über das gesamte Frontend hinweg erfolgen, um eine einheitliche Benutzererfahrung zu gewährleisten.
* *Testen:*
Die implementierten ARIA-Labels sollten regelmäßig mit verschiedenen Screenreadern getestet werden, um sicherzustellen, dass sie korrekt interpretiert werden.

*_Zusammenfassung:_*

<<alt-tag,Alt-Attribute>> und ARIA-Labels sind unverzichtbare Werkzeuge, um die Zugänglichkeit und Benutzerfreundlichkeit von Frontends zu gewährleisten.
Durch sorgfältige Planung und Implementierung dieser Attribute können Designende und Entwickelnde sicherstellen, dass ihre Inhalte für alle Nutzenden zugänglich sind.
Das Beachten der Best Practices beim Schreiben von Alt-Attributen und der Implementierung von ARIA-Labels trägt wesentlich dazu bei, eine inklusive und effiziente Benutzererfahrung zu schaffen.

=== Language Tag

Das lang-Attribut informiert Browser und Unterstützungstechnologien über die Sprache des Inhalts.
Dies hat mehrere Vorteile:

* *Zugänglichkeit:*
Screenreader verwenden das lang-Attribut, um die richtige Aussprache und die korrekten Sprachregeln anzuwenden, was für Nutzende mit Sehbehinderungen von entscheidender Bedeutung ist.
* *Mehrsprachige Frontends:*
Das lang-Attribut ermöglicht es, verschiedene Sprachversionen eines Frontends korrekt zu kennzeichnen und so die Benutzererfahrung zu verbessern.

Um die Sprache zu definieren, können die standardisierten ISO 639-1 Sprachcodes (zwei Buchstaben) genutzt werden (zum Beispiel: de = deutsch).
Dabei gilt es folgende Grundregeln zu beachten:

*_Festlegen der Hauptsprache eines Dokuments_*

Das lang-Attribut sollte im <html>-Tag des Dokuments festgelegt werden, um die Hauptsprache der gesamten Seite anzugeben.
Dies stellt sicher, dass alle Inhalte auf der Seite als in dieser Sprache verfasst erkannt werden.

*_Festlegen der Sprache für spezifische Elemente_*

Wenn einzelne Abschnitte oder Elemente in einer anderen Sprache verfasst sind, sollte das lang-Attribut entsprechend auf diese Elemente angewendet werden.
Dies ist besonders wichtig für mehrsprachige Frontends, Dokumente und die korrekte Aussprache durch Screenreader.
Wenn nötig, können auch spezifische Sprachvarianten oder Dialekte mithilfe von Codes für Regionen oder Länder angegeben werden (zum Beispiel: en-US für amerikanisches Englisch, en-GB für britisches Englisch).

Das lang-Attribut wird nur verwendet, wenn der <<text>> tatsächlich in einer anderen Sprache verfasst ist.
Es wird nicht aus ästhetischen oder stilistischen Gründen gesetzt.

*_Beispiel:_*
[source,xml]
<html lang="de">
    <head>
        <meta charset="UTF-8">
        <title>Mehrsprachige Frontends</title>
    </head>
    <body>
        <h1>Willkommen auf unserem Frontend</h1>
            <p>Dies ist ein Beispieltext in deutscher Sprache.</p>
            <p lang="en">This is a sample text in English.</p>
    </body>
</html>

[[technische-rahmenbedingungen]]
== Technische Rahmenbedingungen

Die technischen Rahmenbedingungen legen fest, welche Technologien und Plattformen für die Umsetzung des Bedienkonzepts verwendet werden sollen.

* Für die Entwicklung von Frontends kommt primär die auf Angular basierte Widget Bibliothek https://primeng.org/installation[PrimeNG] zum Einsatz.
* Ergänzend zu PrimeNG stellt die IsyFact einen Angular-Baustein zur Verfügung.
Dieser beinhaltet behördenspezifische Widgets wie den Anwendungsrahmen oder Eingabefelder für Sonderzeichen.
* Der Baustein liefert ein eigenes Theme, welches die im Bedienkonzept beschriebenen <<allgemeine-prinzipien,allgemeinen Prinzipien>> weitestgehend umsetzt.
Dieses Theme kann bei Bedarf auch durch ein projektspezifisches Theme ersetzt werden.
* Primär ist der Baustein für die Nutzung auf Desktopgeräten konzipiert, kann aber durch die grundlegende Responsivität auch auf mobilen Geräten genutzt werden.

[[fenstertypen-layout]]
== Fenstertypen und Layout

Fenstertypen und Layout bilden die verbindliche Grundlage für Struktur und Verhalten aller Seiten.
Ziel ist eine einheitliche, effiziente und barrierefreie Nutzererfahrung in modernen Fachanwendungen.

Die in Kapitel 2 <<Barrierefreiheit>> beschriebenen Anforderungen (WCAG 2.1 / EN 301 549) gelten uneingeschränkt und bilden den verbindlichen Rahmen.

Die Vorgaben dieses Kapitels sind technologienah formuliert und berücksichtigen die Umsetzung mit Angular sowie den Frameworks PrimeNG und PrimeFlex.
Grundlegende Interaktionsmuster werden im Kapitel <<design-patterns,Design Patterns>> beschrieben.

Die folgenden Gestaltungsprinzipien definieren zentrale Regeln für Struktur, Lesbarkeit und Anpassungsfähigkeit der Benutzeroberfläche und sichern ein konsistentes Erscheinungsbild sowie eine barrierefreie Bedienung über alle Fenstertypen hinweg.

[[gestaltungsprinzipien]]
*_Gestaltungsprinzipien_*

* *Lesbarkeit vor maximale Breite:* Textzeilen werden auf eine angemessene Breite begrenzt.
Auf großen Bildschirmen entstehen bewusst Ränder, anstatt Texte zu strecken.
So bleiben Zeilenlängen und Lesetempo angenehm und kontrollierbar.
* *Reflow statt Schrumpfen:* Mit kleiner werdenden Viewports reduziert sich die Spaltenanzahl.
Bedienelemente behalten ihre Mindestgröße;
Schriften und Interaktionsflächen werden nicht bis zur Unbedienbarkeit verkleinert.
* *Vorhersehbar und konsistent:* Breakpoints, Gutter und Containerbreiten sind klar definiert und wiederverwendbar.
Nutzende erkennen vertraute Muster wieder und müssen keine neuen Bedienweisen erlernen.
* *Standardmäßig barrierearm:* Fokuszustände sind deutlich sichtbar, die Reihenfolge semantisch korrekt, und überlagernde Elemente verdecken den Fokus nicht.
Eine vollständige Tastaturbedienung ist jederzeit möglich.
* *Flexibel, aber geprüft:* Abweichungen innerhalb definierter Spielräume – etwa bei maximalen Breiten – sind zulässig, sofern sie dokumentiert und die festgelegten Akzeptanzkriterien erfüllt sind.

Die konkreten Fenster‑ und Seitentypen (z. B. Login, Dashboard, Dashboard-Unterseite, Applikationsseite, Applikations-Detailseite) sind im Kapitel Entwurfsmuster (<<primaere-fenstertypen>> und <<sekundaere-fenstertypen>>) beschrieben.
Die hier definierten Prinzipien bilden die verbindliche Grundlage für deren Gestaltung und technische Umsetzung.

[[layout-resizing]]
=== Layout und Resizing

==== Zielkorridor & Reflow

Layout und Inhalt müssen auch bei Größenänderungen nutzbar bleiben.
Reflows dürfen die Orientierung der Nutzenden nicht beeinträchtigen.
Das Verhalten folgt den allgemeinen <<gestaltungsprinzipien, Prinzipien zur Lesbarkeit und Anpassungsfähigkeit>>.

[[image-zielkorridor]]
.Zielkorridor für responsive Layouts mit zentriertem, maximal begrenztem Inhaltsbereich
image::zielkorridor_maxwidth.png[align="center", scaledwidth="100%",width="1123",height="750"]

*_Richtlinien_*

[[r-nutzungsbandbreite]]
* *Nutzungsbandbreite:* Das Layout ist im Bereich von 320 bis mindestens 1920 CSS-Pixeln funktionsfähig.
Der Hauptinhalt befindet sich in einem zentrierten Container mit begrenzter Zeilenlänge, um Lesbarkeit und Orientierung zu sichern.

[[r-textvergroesserung-200]]
* *Zoomsicherheit:* Eine Textvergrößerung um bis zu 200 % darf weder zu Funktions- noch zu Informationsverlust führen.
[[r-reflow-400]]
Im Fließtext darf auch bei 400 % Zoom kein horizontales Scrollen erforderlich sein.

[[r-keine-layoutspruenge]]
* *Planbarer Reflow:* Für dynamisch erscheinende Inhalte – etwa Bilder, Fehlermeldungen oder Platzhalter – wird ausreichend Raum vorgesehen, um Layoutsprünge zu vermeiden.

[[r-fokus-nicht-ueberdeckt]]
* *Stabile Überlagerungen:* Overlays und feste Elemente (z. B. Header oder Toolbars) überlagern den Inhalt, anstatt den Dokumentenfluss nachträglich zu verschieben.
Der Fokus bleibt dabei steuerbar und stets sichtbar.

==== Raster, Abstände und Layout-Hilfen

Das Raster ordnet Inhalte in Spalten, während Container und Layout-Utilities die Abstände und die Ausrichtung der Elemente steuern.
Ziel ist ein konsistentes, flexibles und leicht wartbares Layout über alle Bildschirmgrößen hinweg.

[[image-raster-abstaende-layout]]
.Responsives Layout - Breakpoint-basierte Spaltenzahl
image::raster_abstaende_layout.png[align="center", scaledwidth="100%",width="1123",height="680"]

*_Gestaltungsregeln_*

[[r-spaltenreduktion-3-2-1]]
* *Breakpoints*: Die Spaltenanzahl wird stufenweise je nach Bildschirmgröße definiert (z. B. 3 → 2 → 1); dies unterstützt skalierbare Layouts ohne Funktionsverlust.
Individuelle Sondergrößen außerhalb der definierten Design-Tokens sind zu vermeiden.

[[r-konsistente-abstaende]]
* *Abstände*: Zwischenräume werden zentral über Container-Gaps gesteuert.
Gestapelte Margins zwischen Komponenten sollen vermieden werden, um konsistente Abstände sicherzustellen.

[[r-keine-festen-breiten]]
* *Flexible Breiten*: Komponenten passen sich dynamisch der verfügbaren Spaltenbreite an.
Feste Pixelbreiten sind zu vermeiden, damit Reflow und Zoom korrekt funktionieren.

[[r-kontextabhaengige-dichte]]
* *Kontextabhängige Dichte*: Auf großen Viewports darf das Layout kompakt, aber gut lesbar sein.
Auf kleineren Geräten oder bei hohem Zoom werden Zeilenhöhe und Interaktionsflächen leicht vergrößert, um Bedienbarkeit und Lesbarkeit zu verbessern.

==== Formular-Layouts

Formulare führen Nutzende linear durch logisch zusammenhängende Feldgruppen.
Bei geringer Bildschirmbreite oder eingeschränktem Platzangebot wird das Layout automatisch einspaltig dargestellt.

[[image-formular-layouts]]
.Formularraster - Spaltenzahl stufenweise über Breakpoints
image::formular_layouts.png[align="center", scaledwidth="100%",width="1123",height="794"]

*_Umsetzungshinweise_*

[[r-label-feld-naehe]]
* *Label-Feld-Einheit:* Labels und Eingabefelder werden räumlich zusammen platziert.
Dies unterstützt die Blickführung und gewährleistet eine korrekte Interpretation durch assistive Technologien.

[[r-formular-einspaltig]]
* *Resizing:* Das Formularraster reduziert die Spalten je nach Breakpoint.
Unterhalb des mittleren Breakpoints erfolgt die Darstellung einspaltig, um einen klaren, linearen Eingabefluss zu sichern.

[[r-fehlermeldungen-feldnah]]
* *Hinweise und Fehler:* Hilfetexte und Fehlermeldungen sind kurz, feldnah und in reservierten Bereichen anzuzeigen.
Dadurch werden Layoutsprünge und visuelle Unruhe vermieden.

* *Aktionen:* Primäraktionen (z. B. „Speichern“) stehen am Ende des Formulars.
Sekundäraktionen bleiben sichtbar, sind jedoch gestalterisch zurückgenommen.

[[r-tastatur-fokusreihenfolge]]
* *Tastaturbedienung:* Die Fokusreihenfolge entspricht der visuellen Lesereihenfolge und bildet eine durchgängige „Focus Order“ gemäß WCAG 2.4.3 folgt den allgemeinen <<barrierefreies-layoutverhalten,Barrierefreiheitsvorgaben>>.
Navigation mit Tab und Shift + Tab erfolgt ohne Sprünge.

==== Tabellen und dichte Inhalte

Tabellen müssen auch bei begrenztem Platz verständlich und gut nutzbar bleiben.
Die Zuordnung von Spaltenköpfen zu Zellen ist jederzeit nachvollziehbar.

*_Darstellungsstrategien_*

[[r-tabellen-responsiv]]
* *Responsives Verhalten:* Je nach Kontext kann zwischen einer gestapelten Darstellung (Zellen enthalten ihr Label) oder einem horizontal scrollbaren Container gewählt werden.
In beiden Fällen bleiben Spaltenköpfe erkennbar.

[[r-tabellen-priorisierung]]
* *Inhaltliche Priorisierung:* Wichtige Spalten bleiben sichtbar; nachrangige Inhalte können gekürzt oder in Detailansichten ausgelagert werden.

* *Erfassbarkeit:* Texte werden linksbündig, Zahlen rechtsbündig ausgerichtet.
Zeilenhöhen bleiben kompakt, ohne die Bedienbarkeit zu beeinträchtigen.

[[r-tabellen-stabilitaet]]
* *Stabilität:* Leere, Lade- oder Fehlerzustände belegen konstanten Raum, damit das Layout ruhig und stabil bleibt. Das Scrollverhalten orientiert sich an den <<barrierefreies-layoutverhalten,Grundsätzen des barrierefreien Layoutverhaltens>>.

[[barrierefreies-layoutverhalten]]
==== Barrierefreies Layoutverhalten

Barrierefreiheit ist integraler Bestandteil der Layoutlogik.
Interaktionsziele müssen gut erreichbar, Fokuszustände klar erkennbar und Überläufe kontrolliert sein.

*_Kriterien_*

[[r-zielgroessen-minimum]]
* *Zielgrößen:* Interaktive Elemente müssen mindestens 24 × 24 CSS-Pixel groß sein (WCAG AA).
Für eine komfortable Touch-Bedienung wird eine Größe von 44 × 44 CSS-Pixel empfohlen (WCAG AAA).

[[r-fokus-sichtbarkeit-reihenfolge]]
* *Fokusführung:* Der Fokusindikator ist deutlich und kontrastreich.
Die Reihenfolge des Fokus folgt der visuellen Lesereihenfolge.

[[r-lange-inhalte-zugriff]]
* *Lange Inhalte:* Lange Text- oder Datenwerte werden umgebrochen oder mit Auslassungspunkten verkürzt.
Der vollständige Inhalt bleibt über Tooltip oder Detailansicht zugänglich.

[[r-scrollrichtung-vertikal]]
* *Scrollrichtung:* Bevorzugt wird eine vertikale Scrollrichtung.
Horizontal wird nur gescrollt, wenn es fachlich erforderlich ist, beispielsweise bei sehr breiten Tabellen.

[[hauptfenster]]
=== Hauptfenster

Das Hauptfenster bildet den zentralen Rahmen jeder Anwendung.
Es definiert die Grundstruktur aus Header-Bereich und Inhaltsbereich und legt damit das Erscheinungsbild, die Orientierung und die Navigation fest.

[[image-hauptfenster-aufbau]]
.Allgemeiner Aufbau des Hauptfensters
image::hauptfenster.mockup.drawio.svg[align="center"]

*_Das Hauptfenster folgt modernen Usability-Grundsätzen:_*

* *Konsistenz:* Einheitlicher Aufbau und wiedererkennbare Navigation über alle Seiten hinweg.

* *Effizienz:* Schnell erfassbare Informationen und klarer Zugang zu Funktionen.

* *Barrierefreiheit:* Erfüllung der Anforderungen gemäß WCAG 2.2 / EN 301 549, z. B. klare Fokusführung, ausreichende Kontraste und vollständige Tastaturbedienbarkeit.

* *Responsivität:* Anpassungsfähigkeit an verschiedene Bildschirmgrößen ohne Informationsverlust.

Der Header bleibt in Aufbau und Funktion über alle Anwendungen hinweg einheitlich.
Inhaltliche Anpassungen erfolgen nur in einem definierten Rahmen (z. B. Logo der Anwendungslandschaft oder Hauptnavigation).
Der Abschnitt <<header-bereich>> beschreibt die Möglichkeiten zur Gestaltung im Detail.

[[header-bereich]]
==== Header Bereich

Der Header-Bereich enthält allgemeine Informationen zur Anwendungslandschaft, zu den verfügbaren Fachanwendungen und zum angemeldeten Nutzenden.

[[image-header-aufbau]]
.Aufbau des Header-Bereiches
image::header.mockup.drawio.svg[align="center"]

<<image-header-aufbau>> zeigt die Bestandteile des Headers:

* *A* Logo des Anbieters der Anwendungslandschaft
* *B* Balken in der Primärfarbe der Anwendungslandschaft
* *C* Logo der Anwendungslandschaft
* *D* Informationen zum angemeldeten Nutzenden
* *E/F* Haupt- und Subnavigation als Flyout (zur Nutzung siehe <<hauptnavigation>>)

[[r-header-barrierefrei]]
Der Header ist für alle Seiten innerhalb einer Anwendungslandschaft gestalterisch identisch.
Beim Anpassen der Fenstergröße bleiben links ausgerichtete Elemente links und rechts ausgerichtete Elemente rechts; der Raum dazwischen passt sich flexibel an.

Der Header ist vollständig barrierefrei umgesetzt: Fokusreihenfolge, Kontrast und Tastaturbedienung entsprechen den in Kapitel <<barrierefreiheit>> definierten Anforderungen.
Die Informationen zum angemeldeten Nutzenden zeigen mindestens den Namen oder die Kennung und sind auch über Screenreader eindeutig identifizierbar.

*_Richtlinien_*

[[r-skip-link]]
* *Bypass Blocks / Skip-Link:* Am Seitenanfang ist ein fokussierbarer „Zum Inhalt springen“-Link vorhanden, der den Fokus korrekt ins `<main>` setzt.

[[r-landmarks]]
* *Semantische Landmark-Struktur:* Genau ein `<header>`/`role="banner"`, benannte `<nav>`-Landmarks und genau ein `<main>` pro Seite; Landmarks sind eindeutig und nicht redundant.

[[r-konsistente-navigation]]
* *Konsistente Navigation und Identifikation:* Reihenfolge und Bezeichnungen wiederkehrender Navigationsbestandteile sowie die Identifikation von Komponenten bleiben über Seiten hinweg konsistent.

[[inhaltsbereich]]
==== Inhaltsbereich

Der Inhaltsbereich stellt den zentralen Arbeitsraum der Anwendung dar.
Er nutzt ein gemeinsames, responsives Raster, das eine konsistente Anordnung von Komponenten, Formularen und Navigationselementen über alle Fenstertypen hinweg gewährleistet.
Das Layout basiert auf der Angular-Implementierung der IsyFact-Widgets unter Verwendung von PrimeNG und PrimeFlex.

Im Inhaltsbereich werden sowohl Fachinhalte als auch interaktive Elemente angezeigt.
Die Gestaltung orientiert sich an den Prinzipien aus Kapitel <<layout-resizing>> (z. B. Reflow, Spacing, Barrierefreiheit) und berücksichtigt insbesondere:

* *Konsistenz*: Einheitliche Struktur und Abstände für alle Seiten und Anwendungstypen.
* *Responsivität*: Anpassung an verschiedene Bildschirmgrößen und Zoomstufen ohne Informationsverlust.
* *Barrierefreiheit*: Klare Fokusreihenfolge, ausreichende Kontraste und vollständige Tastaturbedienbarkeit.
* *Modularität*: Wiederverwendung standardisierter Komponenten (Widgets, Panels, Tabellen, Dialoge).
Die konkreten Fenster- und Seitentypen, die dieses gemeinsame Raster verwenden, sind in Kapitel <<primaere-fenstertypen>> detailliert beschrieben:

** <<login>>
** <<dashboard>>
** <<dashboard-unterseite>>
** <<applikationsseite>>
** <<applikations-detailseite>>

[[modalarme-interaktionen]]
=== Modalarme Interaktionen (Grundsatz)
Modale Dialoge sind blockierende Overlays innerhalb der Anwendung, die den Hintergrund sperren, den Tastaturfokus einfangen und eine Entscheidung erfordern, bevor weitergearbeitet werden kann.
Dies unterbricht den Arbeitsfluss und erschwert die Orientierung.
Deshalb sollen Interaktionen möglichst im Kontext stattfinden – ohne blockierende Dialoge.
Dieses Prinzip verbessert Effizienz, Barrierefreiheit und die allgemeine Nutzererfahrung.

*_Grundprinzip_*

* *Bevorzugte Muster:* Statt vollständig modaler Fenster werden bevorzugt kontextbezogene Interaktionsmuster eingesetzt – beispielsweise Drawer, Inline-Bestätigungsleisten, Popover, Tooltips oder aufklappbare Bereiche (Accordions/Expander).

* *Modale Dialoge nur bei zwingendem Bedarf:* Ein modaler Dialog darf nur verwendet werden, wenn dies fachlich oder rechtlich erforderlich ist – etwa bei sicherheitsrelevanten oder bestätigungspflichtigen Aktionen.
Solche Fälle müssen im Design-Review begründet werden.

*_Fokus-Management_*

[[r-dialog-fokus-beim-oeffnen]]
* Beim Öffnen wird der Fokus automatisch auf das erste sinnvolle Element oder den Header des neu geöffneten Bereichs gesetzt.

[[r-dialog-fokusfalle]]
* Der Fokus ist innerhalb des Dialogs einzuschließen („Focus Trap“) – Tab und Shift+Tab dürfen nicht aus dem Dialog hinausführen.

[[r-dialog-esc-schliessen]]
* Der Escape-Key (ESC) sollte, sofern fachlich erlaubt, den Dialog schließen.

[[r-dialog-fokus-zum-ausloeser]]
* Beim Schließen kehrt der Fokus zum auslösenden Element zurück.

[[r-keine-sticky-ueberdeckung]]
* Fokuselemente dürfen niemals durch fixierte oder klebende (sticky) Layoutbereiche verdeckt werden.
Falls erforderlich, ist dies durch geeignete Layout-Abstände (z. B. +scroll-margin-top+) sicherzustellen.

*_Zielgrößen_*

Interaktive Elemente müssen ausreichend groß und klar erkennbar sein, um sowohl per Maus als auch per Touch und Tastatur zuverlässig bedienbar zu bleiben.

Für interaktive Elemente gelten die Mindestgrößen gemäß den Vorgaben im barrierefreien <<barrierefreies-layoutverhalten, Layoutverhalten>>.

*_Alternativen zu Drag-Interaktionen_*

[[r-drag-alternative]]
Interaktionen, die standardmäßig Drag-and-Drop verwenden (z. B. Sortieren oder Umordnen), müssen immer auch ohne Drag-Gesten bedienbar sein – beispielsweise über Schaltflächen, Menüeinträge oder Tastaturbefehle.

*_Overflow und Lesbarkeit_*

Layouts mit dichten Benutzeroberflächen sollen klar strukturiert und scrollbar bleiben.

* Standard ist eine vertikale Scrollrichtung; horizontales Scrollen wird nur eingesetzt, wenn es fachlich zwingend erforderlich ist (z. B. bei breiten Tabellen).

* Lange Texte oder Werte werden automatisch umgebrochen oder mit Auslassungspunkten verkürzt.
Vollständige Inhalte bleiben über Tooltip oder Detailansicht zugänglich.

* Inhalte dürfen nie abgeschnitten oder außerhalb des sichtbaren Bereichs verborgen sein.

[[drucklayout]]
=== Drucklayout

Wenn Inhalte aus der Anwendung gedruckt oder als PDF exportiert werden, müssen sie für paged media optimiert sein.
Grundlage bildet ein spezielles Print-Stylesheet über `@media print`.
Wo möglich, werden ergänzend Seitenregeln über `@page` eingesetzt, um Format, Ränder und Kopf-/Fußbereiche zu definieren.
Nicht benötigte UI-Elemente werden ausgeblendet; Farben, Abstände und Umbrüche sind auf gute Lesbarkeit und sparsame Ausgabe (Tinte/Toner) zu optimieren.

[[image-seitendruck1]]
.Seitendruck über Druck-Funktion des Browsers
image::Druck_GesamteSeite.png[align="center", scaledwidth="96%"]

==== Technische Grundlagen

[[r-druck-print-stylesheet]]
* *Print-Stylesheet aktivieren:* Druckspezifische Stile werden über `@media print` angewendet. Alternativ kann ein separates Stylesheet mit media="print" eingebunden werden.

[[r-druck-seitenformat-raender]]
* *Seitenformat, Ränder und Orientierung:* Mit `@page` werden Format (z. B. A4 hochkant) und Seitenränder definiert. 
Diese Vorgaben müssen projektspezifisch geprüft und dokumentiert werden.

[[r-druck-fragmentierung]]
* *Seitenumbrüche und Fragmentierung:* Für stabile Druckausgaben sind die modernen CSS-Eigenschaften break-* (z. B. `break-inside: avoid;`) zu verwenden.
Diese verhindern, dass Tabellenzeilen oder Inhaltsboxen auf mehrere Seiten „zerschnitten“ werden.

[[r-druck-farbanpassung]]
* *Farbanpassung beim Drucken:* Mit `print-color-adjust` lässt sich steuern, ob der Browser Farbwerte verändern darf.
Standardmäßig ist Anpassung durch den User Agent erlaubt; mit dem Wert `exact` kann eine exakte Farbwiedergabe erzwungen werden (sofern vom Browser unterstützt).

[[r-druck-margin-boxes]]
* *Laufende Kopf-/Fußzeilen und Seitenzahlen:* In Chromium-basierten Browsern ab Version 131 (z. B. Chrome/Edge) können per `@page`-Margin-Boxes automatisch Inhalte wie Titel und Seitenzahlen in die Seitenränder gesetzt werden.
Andere Browser (u. a. Firefox/Safari) befinden sich noch in der Umsetzung.
Es sollte daher Progressive Enhancement mit `@supports` eingesetzt werden.
Wo keine native Unterstützung besteht, kann auf Browser-Standardfunktionen oder spezialisierte Engines wie `Paged.js` oder `Prince` zurückgegriffen werden.

==== Richtlinien zur Anwendung

* *Nur relevante Inhalte drucken:* Navigationsleisten, Header, Footer und interaktive Controls (Buttons, Filter, Toolbars) dürfen nicht gedruckt werden.
Sie werden über das Print-Stylesheet ausgeblendet. 

* *Farben auf das notwendige Minimum reduzieren:* Für Hintergründe sind helle Töne zu verwenden; flächige Farben nur, wenn sie semantisch notwendig sind (z. B. Status- oder Legendenfarben).
Farbmanagement erfolgt über `print-color-adjust`.

* *Typografie und Kontrast:* Es muss ausreichender Kontrast im Ausdruck sichergestellt werden.
Textfarben basieren auf den definierten Graustufen des Web-Themes. 

* *Ziel­format:* Standardformat ist A4 hochkant.
Querformat sollte nur bei fachlicher Notwendigkeit (z. B. breite Tabellen) eingesetzt werden.
Das Format wird über `@page` size festgelegt.

* *Metainformationen:* Jede Seite sollte Metainformationen wie Logo, Dokumenttitel, Datum und ggf. den angemeldeten Nutzenden enthalten.

* *Start des Druckvorgangs:*
** Browserdruck (Datei → Drucken / Ctrl + P) verwendet automatisch das Print-Stylesheet.
** Eine explizite „Drucken“-Aktion im UI kann eine optimierte Druckvorschau-Ansicht öffnen, die die zu druckenden Inhalte vorab darstellt.

==== Drucken bestimmter Inhaltsbereiche
Einzelne Inhaltsbereiche (z. B. Tabellen, Detailansichten) können über dedizierte Druck-Buttons vorbereitet und ausgegeben werden.

[[image-darstellungapplication]]
.Tabelle – Darstellung in Applikation
image::Druck_Ergebnisliste.png[align="center", scaledwidth="100%",width="627",height="272"]

[[image-darstellungdruckoption]]
.Tabelle – Darstellung in Druckvorschau
image::Druck_Darstellung_Druckoption.png[align="center", scaledwidth="100%",width="629",height="385"]

{nbsp} +

{empty} +

[[image-detaildarstellungapplication]]
.Detailseite – Darstellung in Applikation
image::Druck_Darstellung_Applikation.png[align="center", scaledwidth="100%",width="629",height="405"]

[[image-darstellungdetaildruck]]
.Detailseite – Darstellung in Druckvorschau
image::Darstellung_In_Druckvorschau.png[align="center", scaledwidth="100%",width="500",height="773"]

*_Richtlinien:_*

* Die allgemeinen Regeln des Drucklayouts gelten weiterhin. Navigation, Buttons und Toolbars werden ausgeblendet, nur inhaltliche Daten werden ausgegeben.
* Eine Druckvorschau-Ansicht sollte auf einer separaten, druckoptimierten Route dargestellt werden.
** Oberhalb der Seite befindet sich ein prominenter „Drucken“-Button, der `window.print()` auslöst.
** Versteckte oder verschachtelte Inhalte (z. B. Tabs, Master-Detail-Bereiche) müssen vollständig linearisiert werden, sodass alle Abschnitte untereinander erscheinen – jeweils mit klarer Überschrift.
* Metainformationen wie Titel und Seitenzahl sollten pro Seite eingebunden werden (je nach Browser-Unterstützung über Margin-Boxen oder Fallbacks).

*_Tabellen:_*

* Spalteninhalte müssen vollständig und lesbar sein; Spaltenbreiten sollten automatisch angepasst werden (`table-layout: auto;`).
* Tabellenzeilen und Kopfbereiche dürfen nicht getrennt werden (`break-inside: avoid;`).
* Lange Tabellen sollen über mehrere Seiten hinweg sauber umbrechen.

*_Formulare:_*

* Formulare müssen in einer einspaltigen, linearisierten Struktur dargestellt werden.
Labels erscheinen neben oder über den jeweiligen Werten.
* Bei mehrspaltigen Formularen werden Spalten untereinander angeordnet, um Lesbarkeit und logische Reihenfolge zu gewährleisten.

=== Normative Bezüge

[cols="3,2,3", options="header"]
|===
| Anforderung | Normbezug | Akzeptanzkriterium

| <<r-nutzungsbandbreite,Nutzungsbandbreite 320–≥1920 px>>
| WCAG 2.2 SC 1.4.10
| Ab 320 CSS-px ohne 2-D-Scroll; Hauptinhalt bleibt lesbar/zentriert.

| <<r-textvergroesserung-200,200 % Text-Resize>>
| WCAG 2.2 SC 1.4.4
| Bei 200 % keine Funktions-/Informationsverluste.

| <<r-reflow-400,Reflow 400 %/320 px ohne X-Scroll>>
| WCAG 2.2 SC 1.4.10
| Im Fließtext bei 400 %/320 px kein horizontales Scrollen.

| <<r-keine-layoutspruenge,Reflow ohne Layoutsprünge>>
| WCAG 2.2 SC 1.4.10
| Dynamik (Bilder/Fehler/Platzhalter) erzeugt keine Sprünge.

| <<r-fokus-nicht-ueberdeckt,Fokus nicht verdeckt (Sticky/Overlays)>>
| WCAG 2.2 SC 2.4.11 / 2.4.12
| Fokusindikator stets sichtbar, nicht überlagert.

| <<r-spaltenreduktion-3-2-1,Spaltenreduktion 3→2→1>>
| WCAG 2.2 SC 1.4.10
| Reflow in Stufen ohne Informationsverlust.

| <<r-konsistente-abstaende,Konsistente Abstände / Text-Spacing>>
| WCAG 2.2 SC 1.4.12
| Erhöhtes Spacing bricht Layout nicht.

| <<r-keine-festen-breiten,Keine festen Pixelbreiten>>
| WCAG 2.2 SC 1.4.10
| Keine Hard-Widths, die X-Scroll erzwingen.

| <<r-kontextabhaengige-dichte,Kontextabhängige Dichte>>
| WCAG 2.2 SC 1.4.12
| Bei hohem Zoom wachsen Zeilenhöhe/Targets leicht.

| <<r-label-feld-naehe,Label-Feld-Nähe & Semantik>>
| WCAG 2.2 SC 1.3.1 / 3.3.2
| Labels programmatisch zugeordnet, visuell feldnah.

| <<r-formular-einspaltig,Formulare einspaltig (schmal)>>
| WCAG 2.2 SC 1.4.10
| Unterhalb Mid-Breakpoint linearisiert.

| <<r-fehlermeldungen-feldnah,Feldnahe Fehlermeldungen>>
| WCAG 2.2 SC 3.3.1 / 3.3.3
| Fehler feldnah, verständlich; Layout bleibt ruhig.

| <<r-tastatur-fokusreihenfolge,Tastatur: Fokusreihenfolge>>
| WCAG 2.2 SC 2.1.1 / 2.4.3
| Vollständige Tastaturbedienung ohne Sprünge.

| <<r-tabellen-responsiv,Tabellen responsiv (gestapelt/X-Scroll)>>
| WCAG 2.2 SC 1.4.10 / 1.3.1
| Schmal: gestapelt mit Labels; breit: X-Scroll, Köpfe sichtbar.

| <<r-tabellen-priorisierung,Wesentliches priorisieren>>
| WCAG 2.2 SC 1.3.1
| Kernspalten sichtbar; Details ausgelagert.

| <<r-tabellen-stabilitaet,Stabile Leer-/Lade-/Fehlerzustände>>
| WCAG 2.2 SC 1.4.10
| Zustände belegen konstanten Raum; keine Sprünge.

| <<r-zielgroessen-minimum,Zielgrößen ≥ 24×24 (44×44 empfohlen)>>
| WCAG 2.2 SC 2.5.8 / 2.5.5
| Ziele ≥ 24×24 px; Touch 44×44 empfohlen.

| <<r-fokus-sichtbarkeit-reihenfolge,Fokus sichtbar & Reihenfolge korrekt>>
| WCAG 2.2 SC 2.4.7 / 2.4.11 / 2.4.12 / 2.4.3
| Fokus klar sichtbar, nicht verdeckt; Reihenfolge logisch.

| <<r-lange-inhalte-zugriff,Lange Inhalte: Zugriff behalten>>
| WCAG 2.2 SC 1.4.13 / 1.4.10
| Gekürztes via Tooltip/Detail vollständig zugänglich.

| <<r-scrollrichtung-vertikal,Primär vertikales Scrollen>>
| WCAG 2.2 SC 1.4.10
| X-Scroll nur, wenn fachlich nötig.

| <<r-header-barrierefrei,Header barrierefrei>>
| WCAG 2.2 SC 2.4.3 / 2.4.7 / 1.4.11
| Tastaturbedienbar; Fokus sichtbar; UI-Kontraste erfüllt.

| <<r-skip-link,Bypass Blocks / Skip-Link>>
| WCAG 2.2 SC 2.4.1
| Fokussierbarer „Zum Inhalt springen“-Link setzt den Fokus korrekt ins `<main>`.

| <<r-landmarks,Semantische Landmark-Struktur>>
| WCAG 2.2 SC 1.3.1 / Technik ARIA11
| Eindeutige Landmarks: ein `<header>`/banner, benannte `<nav>`, genau ein `<main>`.

| <<r-konsistente-navigation,Konsistente Navigation & Identifikation>>
| WCAG 2.2 SC 3.2.3 / 3.2.4
| Reihenfolge/Bezeichnungen wiederkehrender Navigation bleiben konsistent.

| <<r-druck-print-stylesheet,Print-Stylesheet & @page>>
| CSS Paged Media
| Druck/PDF via `@media print` + `@page` (Format, Ränder, Kopf/Fuß).

| <<r-druck-fragmentierung,Seitenumbrüche stabil>>
| CSS Fragmentation
| `break-inside: avoid` verhindert „Zerschneiden“.

| <<r-druck-farbanpassung,Farbhandhabung im Druck>>
| CSS Color Adjustment
| `print-color-adjust` (ggf. `exact`) steuert Farbwiedergabe.

| <<r-druck-margin-boxes,@page Margin-Boxes (Chromium ≥ 131)>>
| CSS Paged Media – Margin Boxes
| Kopf-/Fußinhalte via Margin-Boxes; progressive Fallbacks.
|===

[[basiselemente]]
== Basiselemente

[[farben]]
=== Farben

Farben tragen maßgeblich zur visuellen Identität eines Frontends bei und beeinflussen die Stimmung und Wahrnehmung der Nutzenden.
Im Rahmen dieses Bedienkonzeptes ist die folgende Farbpalette vorgegeben (Stand 03.07.2024):

[[image-farbpalette]]
.Farbpalette
image::24_BE_farbpalette.png[align="center"]

Die Standardpalette wird mit dem IsyFact-Theme ausgeliefert und entsprechend der aktuellen gesetzlichen Lage aktualisiert.
Deshalb kann die ausgelieferte Palette von dem hier dokumentierten Stand abweichen.
Die dazugehörige <<image-farbmatrix,Kontrasttabelle>> der Standardpalette ist im Kapitel <<barrierefreiheit>> zu finden.
Die Farbpalette legt ebenfalls fest, zu welchem Zweck bestimmte Farben eingesetzt werden sollen, zum Beispiel Rot (#A4252C) zur Markierung von Alerts.

*_Dos_*

* Grün = Erfolg, Bestätigung, Korrekt, etc.
* Rot = Fehler, Abbruch, Stopp, etc.

*_Don'ts_*

* Grün = Abbruch, Fehler, Stopp, etc.
* Lila = Weiter, Sekundärbutton, Löschen, etc.

[NOTE]
Sollte die Standardfarbpalette aufgrund der fachlichen Anforderungen nicht ausreichen oder dem Zweck entsprechen, so kann in Einzelfällen von der Standardfarbpalette abgeleitet werden.

[[image-farbpalette-30per]]
.Abgeleitete Farbpalette
image::24_BE_farbpalette_30per.png[align="center"]

Die Ableitung der Standardfarbe für Flächen und Hintergründe liegt bei 30 % Opacity.
Die Ableitung der Standardfarbe für Schriften, Border und Akzente liegt bei +30 % black Opacity, damit ein ausreichend hoher Kontrast gewährleistet werden kann.
Der daraus resultierende Kontrast erfüllt die Bedingungen bis zum Level AAA - große Schrift.

[IMPORTANT]
Die leichten Farben sind auf hellen Hintergrund nicht mehr barrierefrei!

Die Anwendungsfarbe des Frontends ist frei wählbar, aber muss vom Projekt auf Barrierefreiheit geprüft werden.

[[applikationsfarben]]
=== Applikationsfarben

Sofern es möglich und sinnvoll ist, werden Applikationen aufgrund ihrer Fachlichkeit in Gruppen zusammengefasst.
Pro Applikationsgruppe kann eine Farbe definiert werden, welche an verschiedenen Stellen des Applikationsportals eingesetzt wird und so einen Wiedererkennungswert schafft.
Wenn eine Applikation keiner Gruppe zugeordnet werden kann, kann sie für sich alleine stehen und ihre eigene Farbe erhalten.
Bei der Wahl der Farben sind die generellen Richtlinien zur Nutzung von <<farben>> zu berücksichtigen.
Die Farben sollten so gewählt werden, dass ein harmonisches Gesamtbild erhalten bleibt.

Die Applikationsfarbe kommt an folgenden Stellen zum Einsatz:

// ToDo: Beispielbild kann hier ergänzend eingefügt werden
* Hauptnavigation – Farbbalken unterhalb des Headers
* Submenü (Flyout) – Farbbalken am oberen Rand des Menüs
* Widget auf Dashboard – Farbbalken am oberen Rand
* Titelzeile von Detailseiten – Hintergrundfarbe der Titelzeile
* Dialoge der Applikation – Farbbalken oberhalb der Titelzeile

*_Dos_*

* Die Applikationsfarbe repräsentiert eine Gruppe von Applikationen oder eine einzelne Applikation, sofern sie keiner Gruppe zugeordnet werden kann.
* Eine Applikationsgruppe kann immer nur eine Farbe annehmen.
Die Applikationen innerhalb einer Gruppe erhalten keine unterschiedlichen Farben.
* Die Farben sollten so gewählt werden, dass ein harmonisches Gesamtbild erhalten bleibt.

[[icons]]
=== Icons

Icons können als zusätzliche Elemente genutzt werden, um Funktionen und Inhalte auch visuell kenntlich zu machen.
Dabei sollten Icons primär mit <<text>> genutzt werden und so wenig wie möglich alleine stehen.
Wenn Icons alleine als <<icon-button,Icon-Buttons>> oder Aktionselemente genutzt werden, sollte sich auf eine kleinstmögliche Menge beschränkt werden.
Es wird empfohlen alleinstehende Icons mit einer weit verbreiteten und allgemein bekannten Bedeutung zu nutzen.

In der folgenden Tabelle sind mögliche Icons, deren Funktionen sowie die dazugehörige CSS-Klasse aufgeführt.
Eine Gesamtübersicht der zur Verfügung stehenden Icons ist unter https://www.primefaces.org/diamond/icons.xhtml[PrimeFaces Icons] zu finden.

.Übersicht häufig verwendeter Icons
ifdef::backend-pdf[]
[cols="^1a,2,5", options="header", align="center"]
endif::[]
ifdef::backend-html5[]
[cols="^1,2,5", options="header", align="center"]
endif::[]
|====
|Icon |CSS-Klasse |Funktionen

a|image::primeicons/times.svg[width=32,height=32]
|pi-times
|Abbrechen, Ablehnen, Filterzelle leeren, Stornieren

a|image::primeicons/car.svg[width=32,height=32]
|pi-car
|Abholen

a|image::primeicons/sign-out.svg[width=32,height=32]
|pi-sign-out
|Abmelden

a|image::primeicons/sign-in.svg[width=32,height=32]
|pi-sign-in
|Anmelden

a|image::primeicons/unlock.svg[width=32,height=32]
|pi-unlock
|Aktivieren, Freischalten

a|image::primeicons/sync.svg[width=32,height=32]
|pi-sync
|Aktualisieren, Synchronisieren

a|image::primeicons/check.svg[width=32,height=32]
|pi-check
|Akzeptieren, Annehmen, Erledigen, Zustimmen

a|image::primeicons/paperclip.svg[width=32,height=32]
|pi-paperclip
|Anhänge

a|image::primeicons/reply.svg[width=32,height=32]
|pi-reply
|Antworten

a|image::primeicons/eye.svg[width=32,height=32]
|pi-eye
|Anzeigen

a|image::primeicons/file.svg[width=32,height=32]
|pi-file
|Archiv, aus Archiv zurückholen, Dokument erstellen, Erstmeldung

a|image::primeicons/pencil.svg[width=32,height=32]
|pi-pencil
|Bearbeiten, Bearbeitung fortsetzen, Editieren, Korrigieren

a|image::primeicons/user.svg[width=32,height=32]
|pi-user
|Benutzende, Anwendende, Nutzende, Person

a|image::primeicons/image.svg[width=32,height=32]
|pi-image
|Bild, Bild anzeigen

a|image::primeicons/language.svg[width=32,height=32]
|pi-language
|Buchstaben-Picker

a|image::primeicons/download.svg[width=32,height=32]
|pi-download
|Datei laden, Download, Herunterladen, Laden von Daten

a|image::primeicons/list.svg[width=32,height=32]
|pi-list
|Datensatz anzeigen, Detailauskunft, List-Picker (Objektauswahl), Trefferliste

a|image::primeicons/share-alt.svg[width=32,height=32]
|pi-share-alt
|Daten senden, Daten übermitteln, Senden, Versenden, Teilen

a|image::primeicons/print.svg[width=32,height=32]
|pi-print
|Drucken

a|image::primeicons/cog.svg[width=32,height=32]
|pi-cog
|Einstellung, Einstellungen

a|image::primeicons/arrow-up-right.svg[width=32,height=32]
|pi-arrow-up-right
|Eintrag auswählen

a|image::primeicons/minus.svg[width=32,height=32]
|pi-minus
|Entfernen, Löschen

a|image::primeicons/plus.svg[width=32,height=32]
|pi-plus
|Ergänzen, Hinzufügen

a|image::primeicons/bell.svg[width=32,height=32]
|pi-bell
|Erinnerung

a|image::primeicons/upload.svg[width=32,height=32]
|pi-upload
|Hochladen, Upload

a|image::primeicons/exclamation-triangle.svg[width=32,height=32]
|pi-exclamation-triangle
|Fehler, Fehlerhaft, Warnung

a|image::primeicons/eraser.svg[width=32,height=32]
|pi-eraser
|Felder leeren

a|image::primeicons/check-circle.svg[width=32,height=32]
|pi-check-circle
|Fertig, Abgeschlossen

a|image::primeicons/history.svg[width=32,height=32]
|pi-history
|Historie

a|image::primeicons/info-circle.svg[width=32,height=32]
|pi-info-circle
|Info

a|image::primeicons/arrow-circle-down.svg[width=32,height=32]
|pi-arrow-circle-down
|Importieren

// ToDo: arrow circle up muss noch hochgeladen werden
//a|image::primeicons/arrow-circle-up.svg[width=32,height=32]
//|pi-arrow-circle-up
//|Exportieren

a|image::primeicons/calendar.svg[width=32,height=32]
|pi-calendar
|Kalender

ifdef::backend-html5[]
a|image::primeicons/id-card.svg[width=32,height=32]
|pi-id-card
|Kontakt
endif::[]

a|image::primeicons/trash.svg[width=32,height=32]
|pi-trash
|Löschen

a|image::primeicons/envelope.svg[width=32,height=32]
|pi-envelope
|Mail, Nachrichten

a|image::primeicons/folder-open.svg[width=32,height=32]
|pi-folder-open
|Seite öffnen

a|image::primeicons/save.svg[width=32,height=32]
|pi-save
|Sichern, Speichern

a|image::primeicons/search.svg[width=32,height=32]
|pi-search
|Suchen, Suche wiederholen, Neue Suche, Durchsuchen, letzte Suche

a|image::primeicons/arrow-circle-left.svg[width=32,height=32]
|pi-arrow-circle-left
|Vorheriger, Zurück (Navigation)

a|image::primeicons/arrow-circle-right.svg[width=32,height=32]
|pi-arrow-circle-right
|Weiter, Nächster

a|image::primeicons/refresh.svg[width=32,height=32]
|pi-refresh
|Wiederholen

a|image::primeicons/clock.svg[width=32,height=32]
|pi-clock
|Zeit, Time-Picker

a|image::primeicons/star-fill.svg[width=32,height=32]
|pi-star-fill
|Wiedervorlage
|====

[[text]]
=== Text

Textelemente spielen eine entscheidende Rolle bei der Kommunikation mit den Nutzenden.
Um benutzerfreundliche Texte verfassen zu können, ist es wichtig, die Art und Weise zu verstehen, wie Nutzende Texte auffassen und verarbeiten.
In westlichen Kulturen wird in der Regel von links nach rechts und von oben nach unten gelesen.
In Bezug auf Software und User-Interface-Design gilt diese Tatsache jedoch nur eingeschränkt, denn Nutzende lesen die Texte auf einem Bildschirm meistens nicht vollständig, sondern überfliegen sie nur kurz, um die für sie relevanten Informationen zu finden.

Die beim Design eines Frontends eingesetzten Elemente unterscheiden sich auch dadurch, wie stark sie die Aufmerksamkeit der Nutzenden auf sich ziehen.
So werden <<button,Schaltflächen>>, <<label,Labels>> und andere interaktive Elemente gewöhnlich zuerst wahrgenommen, während statischer Text eher selten gelesen wird.
Dieser Abschnitt definiert die typografischen Standards, sprachlichen Richtlinien und Längenbeschränkungen, die dazu beitragen, dass Texte klar, verständlich und ansprechend sind.

Frontends des Bundes sollen über die IT-Landschaft hinweg ein einheitliches Look-and-Feel bieten.
Dies wird über den Einsatz der IsyFact und deren Komponenten gewährleistet.
Dafür ist es notwendig auch bei der Schrift (im weiteren Font) einheitlich vorzugehen.
Zur Anwendung kommt primär BundesSans.

*_BundesSans_*

Diese Schriftart wurde extra für Inhalte des Bundes entwickelt und zur Verfügung gestellt.
Die BundesSans ist eine humanistische serifenlose Schrift.
Rationalität und äußerste Klarheit kennzeichnen ihre Formensprache.
Die BundesSans gehört zu den sogenannten humanistischen Serifenlosen und entspricht den Empfehlungen des https://www.dbsv.org/[DBSV] hinsichtlich der Leserlichkeit von Schrift.
Auch in der DIN 1450 – Leserlichkeit – werden Humanistische Antiqua (mit Serifen) und Groteskschriften (ohne Serifen) als besonders gut leserlich bezeichnet.

_Sprachumfang_

Folgende Sprachen werden von den Schriften BundesSerif, BundesSans und BundesSans Condensed unterstützt (nur lateinische Schriftzeichen):

Afrikaans, Albanisch, Aserbaidschanisch, Asu, Baskisch, Bemba, Bena, Bosnisch, Bretonisch, Cebuano, Chiga, Deutsch, Dänisch, Embu, Englisch, Esperanto, Estnisch, Filipino, Finnisch, Französisch,  Friaulisch, Färöisch, Galizisch, Ganda, Grönländisch, Gusii, Hawaiianisch, Ido, Inari-Samisch, Indonesisch, Interlingua, Irisch, Isländisch, Italienisch, Javanisch, Jju, Jola-Fonyi, Kabuverdianu, Kalenjin, Kamba, Katalanisch, Kikuyu, Kinyarwanda, Kornisch, Korsisch, Kroatisch, Kurdisch, Kölnisch, Lettisch, Ligurisch, Litauisch, Lojban, Lombardisch, Luhya, Luo, Luxemburgisch, Machame, Makhuwa, Makhuwa-Meetto, Makonde, Malagasy, Malaiisch, Maltesisch, Manx, Meru, Mohawk, Morisyen, Māori, Niederdeutsch, Niederländisch, Niedersorbisch, Nord-Ndebele, Nord-Sami, Nord-Sotho, Norwegisch (Bokmål), Norwegisch (Nynorsk), Nyanja, Nyankole, Obersorbisch, Okzitanisch, Oromo, Polnisch, Portugiesisch, Quechua, Rejang, Rombo, Rukiga, Rumänisch, Rundi, Rwa, Rätoromanisch, Samburu, Samoanisch, Sango, Sangu, Sardisch, Schlesisch, Schottisches Gälisch, Schwedisch, Schweizerdeutsch, Sena, Shambala, Shona, Siswati, Slowakisch, Slowenisch, Soga, Somali, Spanisch, Sundanesisch, Swahili, Süd-Ndebele, Süd-Sotho, Taita, Taroko, Teso, Tongaisch, Tschechisch, Tsong, Tswana, Turkmenisch, Türkisch, Ungarisch, Usbekisch, Vunjo, Walisisch, Walliserdeutsch, Wallonisch, Westfriesisch, Wolastoqey, Wolof, Xhosa, Zhuang, Zulu

Die Liste entspricht der Sprachenzeichennorm ISO 639-1-3.

_Nicht-lateinische Fließtextschriften_

Nicht-lateinische Schriften umfassen Schriftsysteme, die anstelle lateinischer Schriftzeichen zum Beispiel arabische, kyrillische oder chinesische Zeichen beinhalten.
Mit einem Schriftsystem lassen sich meist mehrere Sprachen schreiben (zum Beispiel mit dem arabischen Schriftsystem Sprachen wie Arabisch, Urdu, Paschtu, Persisch (Dari/Farsi)).

Die Notwendigkeit der Darstellung nicht-lateinischer Schriften ergibt sich durch die DIN 91379 „Zeichen und definierte Zeichensequenzen in Unicode für die elektronische Verarbeitung von Namen und den Datenaustausch in Europa“ mit Ausgabedatum 2022-08.
Basierend auf UNICODE wurde für jedes nicht-lateinische Zeichen, das in EU-Mitgliedsstaaten verwendet wird, beispielsweise griechische oder kyrillische Zeichen, eine eindeutige Zuordnung zu einem lateinischen Zeichen vorgenommen.
Die DIN 91379 wendet sich vorrangig an Behörden und Organisationen, die IT-Verfahren betreiben, welche dem behördenübergreifenden Datenaustausch oder dem Datenaustausch mit Bürgerinnen, Bürgern sowie der Wirtschaft dienen und deckt in ihrer Gesamtheit die EU-Amtssprachen und die Amtssprachen Islands, Liechtensteins, Norwegens und der Schweiz ab sowie die deutschen Minderheitensprachen.
Um fehlende UNICODE-Zeichen in der BundesSans zu ergänzen, kommt sekundär die Schriftart *Liberation* zum Einsatz.

*_Liberation_*

Die Schriftart Liberation soll ausschließlich für fehlende UNICODE-Zeichen in der BundesSans verwendet werden.
Denn beim Einsatz von Liberation muss beachtet werden, dass bei dieser Schriftart das große I und das kleine l leicht verwechselt werden können.
Da dies einen Verstoß gegen die BITV (Barrierefreie-Informationstechnik-Verordnung) bedeuten würde, muss bei der Darstellung von I und l in jedem Fall auf BundesSans zurückgegriffen werden.

*_Barrierefreiheit von Text_*

Zusätzlich zu einem klar leserlichen Schriftschnitt sind auch die Gestaltungsmerkmale von Text, <<farben,Farbe>> und Größe entsprechend zu berücksichtigen.
Die fehlerhafte Anwendung von Texten kann somit direkt zu einer Reduzierung der Benutzerfreundlichkeit des entsprechenden Frontends führen.

Die Standard-Schriftart für <<bedienelemente>> und Inhalte ist BundesSans (14pt, regular, dunkelgrau #212529).
Grundsätzlich gilt, ausreichende Schriftgrößen sind abhängig vom Betrachtungsabstand, von der Art des Textes und von der Sehschärfe der Lesenden.
Individuelle Schriftgrößen können mit dem Schriftgrößenrechner auf https://www.leserlich.info/werkzeuge/schriftgroessenrechner/index.php[leserlich.info] ermittelt und entsprechend an den Nutzungskreis angepasst werden.

*_Rechtschreibung_*

Zu einem klaren, professionellen Gesamterscheinungsbild trägt auch eine korrekte Rechtschreibung sowie eine konsistente Groß- und Kleinschreibung bei.
Während bei englischsprachigen Frontends zwischen verschiedenen Formen der Groß- und Kleinschreibung unterschieden wird, reicht es bei deutschsprachigen Frontends aus, die korrekte deutsche Rechtschreibung anzuwenden.
Eine Ausnahme besteht darin, dass das erste Wort der Beschriftung eines <<bedienelemente,Bedienelements>> immer großgeschrieben wird, unabhängig von der jeweiligen Wortart.

*_Vermeidung von technischem Jargon_*

Text muss immer in der Sprache der Nutzenden verfasst werden.
Im Folgenden werden einige Beispiele für technische Begriffe und deren Übersetzung in allgemein verständliche Sprache aufgezeigt.

[cols="5a,5a", options="header", align="center"]
|====
|Technischer Begriff |Allgemeiner Begriff

|Dirty State
|Nicht gespeicherte Änderungen

|Mouse-Up-Event
|Maus-Klick

|Reboot
|Neustart

|String-Länge
|Anzahl der Zeichen

|Data Grid
|Tabelle
|====

*_Dos_*

* Die Verwendung verschiedener Schriftarten (über die im Bedienkonzept hinaus vorgegebenen Schriftarten) muss vermieden werden.
* Die Schriftgröße muss immer ausreichend groß sein.
Ein Unterschreiten von Mindestgrößen zugunsten des Platzgewinns muss vermieden werden.
Stattdessen werden andere, platzsparende Mechanismen angewandt wie <<expander>>.
* Die Anzahl verschiedener Schriftgrößen muss auf ein notwendiges Minimum reduziert werden.
* Als Standard-Schrift wird BundesSans 14pt Regular in Dunkelgrau (#212529) empfohlen.
* Es muss sichergestellt sein, dass der <<barrierefreier-einsatz-von-farben,Kontrast der Schriftfarbe zur Hintergrundfarbe>> ausreichend groß ist.
Hier ist der Kontrast größtmöglich zu wählen (zum Beispiel dunkelgraue Schrift auf weißem Hintergrund).
Ist dies aus technischer oder fachlicher Notwendigkeit nicht möglich, so muss der Kontrast bei kleiner Schrift mindestens 4,5:1 entsprechen.
* <<ueberschriften>> und großer/dicker Text müssen einen Mindestkontrast von 3:1 aufweisen.
* Die Nutzung von Fachterminologie muss entsprechend konsistent verwendet werden.

*_Don'ts_*

* Inkonsistente Terminologie.
* Inkonsistente und falsche Groß- und Kleinschreibung.
* Die Verwendung von zu langen Texten und Textblöcken.
* Nutzung von unterstrichenem Text in Textpassagen, außer für <<link,Hyperlinks>>.
* Die Verwendung von redundanten Textinformationen.
* Nutzung von technischem Jargon statt der Sprache der Nutzenden.

[[grafiken]]
=== Grafiken

Bilder und Grafiken ergänzen den <<text>> und vermitteln Informationen auf visuelle Weise.
Sie unterliegen in erster Linie der Fachlichkeit beziehungsweise dem inhaltlichen Kontext und sollten nicht allzu oft als Schmuckgrafiken in Frontends integriert werden.
Hier werden die Leitlinien für die Verwendung von Grafiken festgelegt, einschließlich Stilrichtlinien, Bildgrößen und im Ansatz deren <<barrierefreiheit>>.

Jedes Bild benötigt eine Bildunterschrift und ein aussagekräftiges <<alt-tag,Alt-Attribut>>, um die Barrierefreiheit von Frontends zu unterstützen.
So können die Inhalte für alternative Ausgabegeräte oder beim fehlerhaften Laden zugänglich gemacht werden.
Des Weiteren soll die Bildgröße an den Inhalt angepasst werden, um sicherzustellen, dass die Informationen den Nutzenden übermittelt werden und kein horizontales Scrolling erforderlich ist.

*_Schriftgrafiken_*

Schriftgrafiken können nicht oder nur eingeschränkt an Benutzeranforderungen angepasst werden, weshalb sie nicht genutzt werden dürfen.
Logos sind hiervon ausgenommen.
Gründe dafür sind, dass ihre Farben und Schriftgrößen nicht individuell eingestellt werden können und die Schriftkanten bei einer Zoomvergrößerung meist unscharf werden.

*_Schmuckgrafiken_*

Schmuckgrafiken können zwar genutzt werden, sollten jedoch so wenig wie möglich eingesetzt werden.
Solche Grafiken müssen entsprechend als Schmuckgrafik gekennzeichnet sein und benötigen deshalb auch keine Alt-Attribute.

*_Dos_*

* Bilder benötigen eine Bildunterschrift.
* Grafiken müssen ein aussagekräftiges <<alt-tag,Alt-Attribut>> besitzen.
* Das Bildmaterial muss ausreichend hoch aufgelöst sein, sodass keine Fragmente erkennbar sind.
* Schmuckgrafiken sind erlaubt, müssen jedoch entsprechend gekennzeichnet werden.

*_Don'ts_*

* Bilder dürfen nicht gegen deutsches Recht verstoßen, politisch, sexuell oder angreifend sein.
* Bilder dürfen keine Schriftgrafiken enthalten, ausgenommen Logos.
In Ausnahmefällen muss die Schriftgrafik beispielsweise durch Alt-Attribute ausreichend beschrieben sein.

[[ueberschriften]]
=== Überschriften

Überschriften ermöglichen es Nutzenden, schnell die Hauptthemen einer Seite zu erfassen und sich zu orientieren.
Sie helfen, Inhalte in logische Abschnitte zu gliedern, wodurch Nutzende die Informationen leichter aufnehmen und navigieren können.

*_Best Practices für die Verwendung von Überschriften_*

* *Hierarchische Ordnung:*
Überschriften sollten in einer klaren hierarchischen Struktur verwendet werden.
Die Hauptüberschrift (<h1>) sollte nur einmal pro Seite verwendet werden, gefolgt von Unterüberschriften (<h2>, <h3>, etc.) in absteigender Reihenfolge.
* *Einheitliches Design:*
Überschriften sollten über das gesamte Frontend hinweg einheitlich gestaltet sein, um ein kohärentes Erscheinungsbild zu gewährleisten.
Dies umfasst Schriftart, -größe, -farbe und -stil.
* *Abstände und Margins:*
Angemessene Abstände vor und nach den Überschriften verbessern die Lesbarkeit und visuelle Struktur der Seite.

*_Zugänglichkeit_*

* *Beschreibende Texte:*
Überschriften sollten aussagekräftig und beschreibend sein, um den Inhalt des folgenden Abschnitts klar zu kommunizieren.
Dies hilft sowohl Nutzenden als auch Suchmaschinen, die Relevanz des Inhalts zu erkennen.
* *Verwendung von ARIA-Rollen:*
In Fällen, in denen Überschriften nicht aus Standard-HTML-Überschriften-Tags bestehen, können ARIA-Rollen verwendet werden, um die Struktur zu erhalten.
Beispiel:
[source,xml]
<div role="heading" aria-level="2">Unterüberschrift</div>

*_Typografie und Design_*

* *Klarheit und Lesbarkeit:*
Die zu verwendende Schriftart ist BundesSans und sollte mindestens 14pt groß sein.
Die Hauptüberschrift sollte deutlich größer und auffälliger als der normale <<text>> sein.
* *Kontrast:*
Der Kontrast sollte mindestens 4,5:1 sein, um die Lesbarkeit zu maximieren.

*_Stile und Akzente_*

* *Fettdruck und Kursivschrift:*
Fettdruck oder Kursivschrift können verwendet werden, um wichtige Überschriften hervorzuheben, jedoch sollte dies sparsam geschehen, um eine Überladung zu vermeiden.
* *Farben:*
<<farben>> können verwendet werden, um Hierarchieebenen zu betonen, sollten jedoch mit Bedacht gewählt werden, um ein harmonisches Gesamtbild zu bewahren.
Es wird empfohlen die Standardfarben zu nutzen.

[[label]]
=== Label

Labels dienen dazu, <<eingabefeld,Eingabefelder>> und andere <<bedienelemente>> klar zu kennzeichnen, sodass Nutzende genau verstehen, welche Informationen erforderlich sind und welche Aktionen durchgeführt werden können.
Ein konsistentes und gut durchdachtes Design von Labels trägt wesentlich zur Verbesserung der Benutzererfahrung bei.

Labels sind nicht nur visuelle Hinweise, sondern auch wesentliche Bestandteile der <<barrierefreiheit>>.
Sie ermöglichen es Screenreadern, die Beziehung zwischen einem Eingabefeld und seiner Beschreibung zu verstehen, was besonders für sehbehinderte Nutzende von großer Bedeutung ist.
Ein korrekt implementiertes Label sorgt dafür, dass alle Nutzenden, unabhängig von ihren Fähigkeiten, <<formulare>> und andere interaktive Elemente problemlos nutzen können.

*_Best Practices für die Verwendung von Labels_*

* *Eindeutige Beschreibung:*
Labels sollten klar und eindeutig beschreiben, was von den Nutzenden erwartet wird.
Beispielsweise sollte ein Label für ein Namensfeld "Vollständiger Name" und nicht nur "Name" lauten.
* *Eindeutige Kennzeichnung von Pflichtfeldern:*
Labels, die ein Pflichtfeld kennzeichnen, werden immer am Ende mit einem Asterisk (pass:[*]) gekennzeichnet.
Es wird empfohlen das Asterisk farblich nicht vom Label abzuheben.
* *Kurze Formulierungen:*
Labels sollten kurz und prägnant sein, um die Benutzerfreundlichkeit zu maximieren.
Labels mit mehr als drei Wörtern sollten vermieden werden.
* *Nähe zum Eingabefeld:*
Labels sollten in unmittelbarer Nähe des zugehörigen Eingabefelds platziert werden – entweder darüber oder links davon, um eine klare Zuordnung zu gewährleisten.
* *Ausrichtung:*
Labels können linksbündig oder rechtsbündig zum Eingabefeld ausgerichtet sein, wobei linksbündige Labels tendenziell besser lesbar und benutzerfreundlicher sind.

*_Zugänglichkeit_*

* *HTML-For-Attribut:*
Jedes Label sollte das for-Attribut verwenden, das mit der ID des entsprechenden Eingabefelds übereinstimmt.
Dies stellt sicher, dass Screenreader die Verbindung zwischen Label und Eingabefeld korrekt interpretieren können.
Beispiel:
[source,xml]
<label for="email">E-Mail-Adresse</label>
<input type="email" id="email">

* *Vermeidung von Platzhaltern als Labels:*
Platzhaltertexte (Placeholder) sollten nicht als Ersatz für Labels verwendet werden, da sie verschwinden, sobald der Nutzende mit der Eingabe beginnt.
Dies kann die Benutzerfreundlichkeit und Zugänglichkeit beeinträchtigen.

*_Stil und Design_*

* *Lesbarkeit:*
Labels sollten in einer gut lesbaren Schriftart und -größe dargestellt werden - mindestens 14pt.
Der Kontrast muss mindestens 4,5:1 betragen, um auch bei schlechten Lichtverhältnissen gut lesbar zu sein.
* *Konsistenz:*
Die Gestaltung von Labels sollte über das gesamte Frontend hinweg konsistent sein.
Einheitliche <<text,Schriftarten>>, Größen und Abstände tragen zur Benutzerfreundlichkeit und einem professionellen Erscheinungsbild bei.

*_Interaktive Elemente_*

*Schaltflächen und Links:*
Labels können auch für interaktive Elemente wie <<button,Schaltflächen>> und <<link,Links>> verwendet werden.
Hier sollten <<aria-labels,ARIA-Labels>> (aria-label) oder ARIA-Beschreibungen (aria-labelledby) eingesetzt werden, um die Zugänglichkeit zu verbessern.
Beispiel:
[source,xml]
<button aria-label="Schließen">X</button>

[[bedienelemente]]
== Bedienelemente

Bedienelemente sind die Bausteine der Benutzeroberfläche, die es den Nutzenden ermöglichen, mit dem Frontend zu interagieren.
Dieser Abschnitt definiert die verschiedenen Bedienelemente und legt fest, wie sie gestaltet und angeordnet werden sollen, um eine intuitive Benutzererfahrung zu gewährleisten.

[[button]]
=== Button

Ein Button dient dazu, Aktionen auszulösen, wie das Einreichen von <<formulare,Formularen>>, das Navigieren zu anderen Seiten oder das Ausführen spezifischer Funktionen innerhalb der Anwendung.
Bei der Gestaltung von Buttons ist es wichtig, auf klare Beschriftungen, ansprechende visuelle Gestaltung und intuitive Platzierung zu achten, um die Benutzerfreundlichkeit zu maximieren.
Nachfolgend werden die verschiedenen Arten von Buttons und ihre Anwendung in der IsyFact beschrieben.

[[colored-button]]
==== Kolorierte Button

Kolorierte Buttons oder auch farbig gefüllte Buttons sind die am häufigsten verwendete Button-Variante.
Grundsätzlich handelt es sich um minimal abgerundete Rechtecke, die ein <<label,Textlabel>>, ein <<icons,Icon>> oder eine Kombination aus beidem enthalten und farblich gefüllt sind.
Aufgrund ihrer kräftigen <<farben,Farbe>> werden sie auch CTA-Buttons (Call-To-Action Buttons) genannt.

Je nach Zustand des Buttons unterscheiden sich die eingesetzten Farben und Fokus-Border voneinander.
Dies ist in der folgenden Abbildung <<image-standardbutton>> dargestellt.

[[image-standardbutton]]
.Zustände von beschrifteten Buttons in Primärfarbe
image::24_BE_Primary_Button_States.png[align="center"]

In diesem Beispiel wurde die Primärfarbe Blau (mit weißer Schrift) verwendet, um die unterschiedlichen Zustände eines Buttons zu veranschaulichen.
In den Zuständen "Hover" und "Pressed" wird die Button-Farbe dunkler als im Normalzustand.
Entsprechend wird die Button-Farbe im Zustand "Disabled" heller.
Im "aktiven" beziehungsweise "fokussierten" Zustand bekommt der Button einen Fokus-Rahmen, der einen helleren Ton hat als der Button selbst.
Die Button-Farbe bleibt jedoch die gleiche wie im Normalzustand.
Dies lässt sich beim Einsatz der anderen Farben, wie in Abbildung <<image-buttoncolors>> exemplarisch zu sehen, ebenso anwenden.

*_Farbwahl bei Buttons_*

Die folgende Grafik zeigt die zulässigen Farben, die im Frontend für Button-Elemente verwendet werden dürfen:

[[image-buttoncolors]]
.Farben von kolorierten Buttons
image::24_BE_Colored_Buttons.png[align="center"]

Hauptsächlich kommen die Primärfarbe Blau und die Sekundärfarbe Orange zum Einsatz, um die Wichtigkeit der einzelnen Aktionselemente innerhalb eines Frontends voneinander zu unterscheiden.
Wenn mehrere Buttons in einem Frontend eingesetzt werden, wird der Button mit dem wichtigsten Ziel beziehungsweise mit der am häufigsten genutzten Aktion innerhalb einer inhaltlichen Gruppe in der Primärfarbe dargestellt.
Ein Beispiel dafür sind Log-In-Seiten von Social-Media-Plattformen.
Die Hauptaufgabe dieser Seite ist es, neue Mitgliedschaften zu generieren, weshalb der Registrieren-Button die Primärfarbe erhält und nicht der Log-In-Button.

In der Regel wird nur ein Button innerhalb der sichtbaren Bedienoberfläche in der Primärfarbe eingefärbt.
Dies hilft den Nutzenden sich auf die Hauptaktion zu fokussieren.

Für manche Aktionen sollten spezielle Farben verwendet werden, die eine bestimmte Bedeutung haben, zum Beispiel Grün für Erfolg oder Rot für Alarm.
Vor allem bei Aktionen, die nicht wieder rückgängig gemacht werden können, wie Löschen oder Entfernen, kann ein roter "Alarm"-Button sehr hilfreich sein.
Diese Signalfarbe veranlasst den Nutzenden noch einmal über seine Aktion nachzudenken, da diese nach der Bestätigung endgültig ist.
Alle anderen Buttons werden in der Sekundärfarbe oder als <<inverted-button,invertierte Buttons>> dargestellt.
Insgesamt sollte die Anzahl der genutzten Farben innerhalb einer Benutzeroberfläche nicht zu hoch sein, um das Frontend nicht zu überladen.

*_Platzierung der Buttons_*

Bei der Platzierung der Buttons innerhalb eines Frontends wird zwischen zwei Use Cases unterschieden.
Bei kleinen Dialogfenstern, in denen lediglich zwischen Akzeptieren und Abbrechen einer Aktion unterschieden wird, wird der Primär-Button rechts unten platziert.

Auf <<formulare,Formularseiten>> oder auch Full-Page-Designs ist die Häufigkeit der Verwendung der Buttons ausschlaggebend.
Buttons für primäre, einleitende und abschließende Aktionen können sehr präsent in der Mitte des Frontends angeordnet werden.
Buttons für navigierende und häufiger verwendete Aktionen werden bevorzugt rechts angeordnet, da die Aufmerksamkeit der Nutzenden während des Lesens oder Hinzufügens von Informationen dorthin gerichtet ist.
Es ist darauf zu achten, dass die Anordnung der Buttons mit identischem Zweck über das gesamte Frontend hinweg konsistent bleibt.

*_Abgrenzung zu anderen Bedienelementen_*

Da Buttons als Aktionselemente eingesetzt werden, dürfen diese nicht genutzt werden, um Selektionen aus einer Gruppe von Optionen zu treffen.
Stattdessen werden <<radiobutton,Radiobuttons>>, <<checkbox,Checkboxen>> oder <<input-switch,Input Switches>> verwendet.
Wenn nur das Textlabel ohne farbliche und räumliche Abgrenzung zum Hintergrund verwendet wird, kommt kein Button, sondern ein <<link>> zum Einsatz (beispielsweise bei Fließtexten oder Seitenleisten).

*_Dos_*

* Beim Aktivieren eines Buttons wird immer eine Funktion ausgelöst oder eine (Fehler-)Meldung sichtbar.
* Buttons mit dem wichtigsten Ziel beziehungsweise mit der am häufigsten genutzten Aktion werden in der Primärfarbe dargestellt.
Falls es unklar ist, welche Aktion wichtiger ist, wird die Standardaktion als primäre Aktion angesehen und entsprechend gefärbt.
* Das <<label>> sollte kurz und selbsterklärend sein.
* Das Label sollte die auszuführende Aktion beschreiben (zum Beispiel Öffnen, Löschen, Speichern, Weiter).
* Wenn ein Button einen Dialog aufruft, sollte der resultierende Dialog die Beschriftung des Buttons als Titel wiederholen.
* Die Schaltfläche für Buttons beträgt mindestens 44px x 44px.
* Die Breite eines Buttons soll sich am enthaltenen Label orientieren.
* Nebeneinanderstehende Buttons können unterschiedlich breit sein, wenn die jeweiligen Labels unterschiedlich groß sind.
* Ein Button soll nach Möglichkeit so platziert werden, dass mögliche Beziehungen zu anderen Elementen deutlich werden.
* Wenn nach einem Klick auf einen Button die Ergebnisaktion nicht sofort ersichtlich ist, soll dies durch ein System-Feedback (zum Beispiel durch eine <<fortschrittsanzeige>>) veranschaulicht werden.

*_Don'ts_*

* Buttons werden nicht zum Selektieren oder Auswählen von Inhalten verwendet.
Hier werden die Bedienelemente <<radiobutton>> und <<checkbox>> eingesetzt.
* Zum Ein- oder Ausschalten von Inhalten werden keine Buttons verwendet, sondern spezielle <<input-switch,Input Switches>>.
* Innerhalb von Fließtexten oder zum Verweisen auf externe Inhalte kommen keine Buttons zum Einsatz.
Stattdessen werden <<link,Links>> genutzt.
* Um ein Frontend farblich nicht zu überladen, sollten nicht zu viele Button-Farben für spezielle Aktionen eingesetzt werden.

[[inverted-button]]
==== Invertierte Button

Falls die <<image-buttoncolors,farblich gefüllten Buttons>> das Frontend zu bunt werden lassen, weil es zu viele Funktionen auf einer Seite gibt, können für sekundäre Funktionen die invertierten Varianten der Buttons genutzt werden.
Jedoch braucht es innerhalb einer Frontend-Seite immer einen farblich kolorierten Button in der Primärfarbe, der die Hauptaktion darstellt.
Dieser Button kann nicht durch seine invertierte Variante ersetzt werden.

[[image-buttoncolors-inverted]]
.Farben von invertierten Buttons
image::24_BE_Outlined_Buttons.png[align="center"]

Bei der invertierten Button-Variante ist die Button-Farbe für jeden Aktionsbutton weiß und nur die Schrift und die Button-Border farblich eingefärbt.
Die unterschiedlichen Button-Zustände lassen sich wie bei den farblich gefüllten Buttons voneinander abgrenzen.
Das heißt, bei den Zuständen "Hover" und "Pressed" wird die Button-Farbe, die nicht mehr weiß, sondern mit der Button-Schriftfarbe vermischt ist, dunkler und beim Zustand "Disabled" heller.
Im "aktiven" beziehungsweise "fokussierten" Zustand erhält der Button einen Fokus-Rahmen, der einen helleren Ton als die Button-Rahmenfarbe aufweist.

[TIP]
Invertierte Buttons werden häufig genutzt, wenn es mehr als zwei Aktionen auf einer Seite gibt oder wenn einer Aktion ein besonderer Fokus eingeräumt werden soll, wie zum Beispiel beim "Registrieren".
Das heißt nach der Nutzung eines <<colored-button,kolorierten Buttons>> in der Primärfarbe kann auf die invertierten Buttons umgestiegen werden.
Eine Kombination aus farblich kolorierten (ausgenommen der Primärfarbe) und invertierten Buttons ist jedoch nicht zulässig.
Es sollte eine der beiden Varianten konsistent im gesamten Frontend benutzt werden.

[[icon-button]]
==== Icon-Button

Icon-Buttons sind Buttons die kein sichtbares Label haben, sondern nur aus einem aussagekräftigen <<icons,Icon>> bestehen.
Sie sind rund und haben einen farbigen Rand, um sich vom Hintergrund oder anderen <<basiselemente,Basis>>- und <<bedienelemente,Bedienelementen>> abzugrenzen.
Dabei ist es essenziell, dass das Icon die dahinterstehende Funktionalität ausdrückt.
Bei der Entwicklung muss darauf geachtet werden, dass Icon-Buttons durch ein <<aria-labels,ARIA-Label>> für Screenreader zugänglich sind.

Generell sollten Icon-Buttons mit Bedacht eingesetzt werden und können somit nicht jeden beliebigen beschrifteten Button ersetzen.
Am häufigsten wird diese Button-Art in Kombination mit einer Aktion eines Bedienelements oder <<design-pattern,Design Patterns>> genutzt, wie zum Beispiel in der Aktionsspalte einer Tabelle oder zum Hinzufügen oder Löschen von Elementen.

[[image-iconbuttons]]
.Icon-Buttons
image::24_BE_Round_Buttons.png[align="center"]

Der Farbeinsatz und die verschiedenen Zustände der Icon-Buttons sind genauso wie bei den Button-Varianten zuvor.
Für positive Aktionen wird das grüne Styling, für negative Aktionen das rote Styling und für informierende Aktionen das blaue Styling genutzt.
Sie unterscheiden sich lediglich in der Form und Größe.

Beim Hovern über einen Icon-Button kann ein Tooltip angezeigt werden, der die entsprechende Funktionalität beschreibt.
Ist diese Beschreibung jedoch zu lang (mehr als drei Wörter), ist das Icon nicht dazu geeignet, einen beschrifteten Button zu ersetzen.

*Sonderfall:*

In speziellen Fällen werden Icon-Buttons auch ohne ihre Border dargestellt.
Hierbei ist es besonders wichtig, dass die Icon-Buttons passend zum Design Pattern gewählt werden.
Diese werden beispielsweise innerhalb von Tabellenheadern zum Sortieren und Filtern der Tabelleninhalte verwendet und sehen wie folgt aus:

[[image-iconbuttons-withoutborder]]
.Icon-Buttons ohne Border
image::24_BE_Icons.png[align="center"]


*_Dos_*

* Die Schaltfläche für Icon-Buttons beträgt mindestens 44px x 44px.
* Ein Icon-Button ohne Border muss so platziert werden, dass die Beziehungen zu anderen Elementen deutlich werden.

[[link]]
=== Hyperlink

Hyperlinks sind verlinkte <<text,Texte>> (oder auch <<grafiken>>), die im Wesentlichen als Navigationsmechanismus dienen, zum Beispiel um neue Fenster mit anderen Inhalten zu öffnen.
Wird die Maus über einen Hyperlink bewegt, ändert sich der Cursor vom Pfeil zum Handsymbol.
Hyperlinks folgen per Default einem einheitlichen Styling und sind in der Regel unterstrichen.
Da Nutzende daran gewöhnt sind, weiterführende Informationen/Links in einem Fließtext oder auf einer Seite anhand des unterstrichenen Textes zu erkennen, ist es nicht ratsam, daran etwas zu ändern.

Hyperlinks können den Status (State) "normal", "hovered/focus" und "clicked" haben.
 
[[image-hyperlinks]]
.States von Hyperlinks
image::24_BE_Links.png[align="center"]

Hyperlinks benötigen zwingend ein farbunabhängiges Element zum Identifizieren und Erkennen des States.

[TIP]
Hyperlinks sollten aussagekräftig beschriftet sein.
Generische Phrasen wie „Hier klicken“ sind nicht hilfreich und sollten vermieden werden.

[[eingabefeld]]
=== Eingabefeld

Eingabefelder sind grundlegende Interaktionselemente in einer Benutzeroberfläche, die es den Nutzenden ermöglichen, Daten einzugeben, zu bearbeiten oder auszuwählen.
Sie spielen eine zentrale Rolle bei der Interaktion zwischen Nutzenden und System.
Sie kommen in verschiedensten Formen und Kontexten vor, sei es in Form von Textfeldern, <<dropdown,Dropdown-Menüs>>, <<liste,Auswahllisten>> oder Datumsauswahlkalendern.
Die Gestaltung und Platzierung von Eingabefeldern hat direkten Einfluss auf die Benutzererfahrung und die Effizienz der Dateneingabe.

Eingabefelder sind dynamisch.
Sie bestehen aus dem Eingabefeld selbst, einem vorbelegten Platzhalter (<<placeholder,Placeholder>>) und optional aus einer daraus entstehenden <<eingabefeld-mit-mask,Vorschau (Mask)>> zur Anzeige des erwarteten Formats.
Bei der Gestaltung des Labels gibt es zwei Möglichkeiten.
Das Label ist "regular" oder "bold".

*_Normal:_*

[[image-eingabefeldplatzhalter]]
.Eingabefeld mit Platzhalter
image::24_BE_eingabefeld_normal.png[align="center"]

oder

[[image-eingabefeldplatzhalter-bold]]
.Eingabefeld mit Platzhalter und "bold"-Label
image::24_BE_eingabefeld_bold_normal.png[align="center"]

Im Normalzustand ist das Eingabefeld mit einem bündigen, statischen <<label>> in Dunkelgrau versehen.
Der Platzhalter ist in einem helleren Grau gehalten.
Platzhalter müssen sinnvolle Eingabeunterstützungen (im einfachsten Fall das Label selbst) enthalten.

*_Aktiv:_*

[[image-eingabefeldaktiv]]
.Eingabefeld aktiv
image::24_BE_eingabefeld_active.png[align="center"]

oder

[[image-eingabefeldaktiv-bold]]
.Eingabefeld aktiv mit "bold"-Label
image::24_BE_eingabefeld_bold_active.png[align="center"]

Aktive Eingabefelder werden mit einer 1px dickeren Umrandung in der Highlightfarbe Blau dargestellt.
Sie verlieren ihren Platzhalter und können entweder geleert werden (siehe Abbildung <<image-eingabefeldaktiv>>) oder eine Mask enthalten (siehe Abbildung <<image-eingabefeldmask>>).

*_Befülltes Eingabefeld:_*

[[image-eingabefeldfilled]]
.Eingabefeld befüllt, nicht aktiv
image::24_BE_eingabefeld_filled.png[align="center"]

oder

[[image-eingabefeldfilled-bold]]
.Eingabefeld befüllt, nicht aktiv mit "bold"-Label
image::24_BE_eingabefeld_filled.png[align="center"]


Wenn eine Eingabe in einem Eingabefeld getätigt wurde und das Feld wieder verlassen wird, wechselt das Eingabefeld wieder in den Normalzustand mit dem Unterschied, dass der Platzhalter verschwunden ist und die Eingabe angezeigt wird.

*_Disabled:_*

[[image-eingabefelddisabled]]
.Eingabefeld disabled
image::24_BE_eingabefeld_disabled.png[align="center"]

oder

[[image-eingabefelddisabled-bold]]
.Eingabefeld disabled mit "bold"-Label
image::24_BE_eingabefeld_bold_disabled.png[align="center"]

Deaktivierte Eingabefelder (disabled) sind grau hinterlegt und geben zusätzlich über einen Mouse-Cursor-Wechsel beim Hovern den Disabled State wieder.
Disabled Felder werden *nur* eingesetzt, wenn der Inhalt zum aktuellen Zeitpunkt nicht relevant ist.
Disabled-Elemente müssen nicht für den Screenreader oder andere Unterstützungstechnologien zugänglich sein.

*_Readonly:_*

[[image-eingabefeldreadonly]]
.Readonly-Eingabefeld
image::24_BE_eingabefeld_read_only.png[align="center"]

oder

[[image-eingabefeldreadonly-bold]]
.Readonly-Eingabefeld mit "bold"-Label
image::24_BE_eingabefeld_bold_readonly.png[align="center"]

Im Gegensatz zu einem deaktivierten Eingabefeld sind Readonly-Eingabefelder für Screenreader und andere Unterstützungstechnologien zugänglich und ihr Inhalt für die Nutzenden zum Zeitpunkt der Interaktion relevant.
Deaktivierte Felder haben einen Standardhintergrund und sehr hellen Rand.
Die enthaltene Information lässt sich aus dem Eingabefeld auslesen (auch durch Screenreader oder andere Unterstützungstechnologien) zum Beispiel durch die Tastenkombination "Strg + C".
Die Information ist zum aktuellen Zeitpunkt relevant, kann aber nicht verändert werden.

*_Eingabefeld als Pflichtfeld:_*

[[image-eingabefeldpflichtfeld]]
.Eingabefeld als Pflichtfeld
image::24_BE_eingabefeld_required.png[align="center"]

oder

[[image-eingabefeldpflichtfeld-bold]]
.Eingabefeld als Pflichtfeld mit "bold"-Label
image::24_BE_eingabefeld_bold_required.png[align="center"]

Ein Eingabefeld als Pflichtfeld ist im Grunde ein normales Eingabefeld mit der Besonderheit, dass es befüllt werden muss.
Die "Pflicht"-Kennzeichnung erfolgt dabei durch das Label und wird durch einen Asterisk (*) dargestellt.
Der Asterisk wird immer ans Ende eines Labels gestellt.
Pflichtfelder haben immer eine Validierung und eine entsprechende Fehlermeldung, die bei einer fehlerhaften Eingabe unterhalb des Eingabefeldes sichtbar wird (siehe zum Beispiel Abbildung <<image-eingabefelderror>>).

[NOTE]
Ein Pflichtfeld kann zusätzlich durch die Deklaration des Platzhalters mit "Pflichtfeld" oder "required" gekennzeichnet werden.

*_Eingabefeld mit Fehlermeldung und Hinweis:_*

[[image-eingabefelderror]]
.Eingabefeld und Fehlermeldung
image::24_BE_eingabefeld_error.png[align="center"]

oder

[[image-eingabefelderror-bold]]
.Eingabefeld und Fehlermeldung mit "bold"-Label
image::24_BE_eingabefeld_bold_error.png[align="center"]

Bei einer Fehlermeldung färbt sich das Eingabefeld rot und es wird ein inhaltlich logischer Hinweistext (auch in Rot) angegeben, damit die Eingabe korrigiert werden kann.
Das Label des Eingabefeldes wird bei einem Fehler nicht verändert.

Eingabefelder, die eine Erläuterung benötigen, sollen diese immer so kurz wie möglich und so lang wie nötig gestalten.
Erläuterungen können dabei unterschiedlich realisiert werden, sortiert von kurz nach lang:

* als Platzhalter im Eingabefeld selbst.
* als Klammeranhang am Label, um das Label zu erläutern, zum Beispiel: Name (gemeint ist der eingetragene Familienname).
* als maximal zweizeiliger Hinweistext unter oder über dem Label (bitte nach Entscheidung konsistent im gesamten Frontend damit fortfahren).

Alle Erläuterungstexte, die mehr als zwei Zeilen einer Eingabefeldlänge benötigen, sind zu komplex gestaltet und bedürfen einer fachlichen Neugestaltung.
Sollte dies nicht möglich sein, so ist ein vorangehendes Textelement über dem Eingabefeld notwendig.
Erklärungshilfen, sollen nicht dynamisch versteckt werden – entweder ist die Erläuterung notwendig, dann sollte sie sichtbar sein oder sie ist nicht notwendig, sodass sie entfernt werden kann.

*_Allgemeine Hinweise zu Eingabefeldern:_*

Ein Eingabefeld hat keine fixe Länge.
Ein Eingabefeld ist so lang, wie es der fachliche Kontext notwendig macht.
Wenn beispielsweise 95 % der erwarteten Eingaben deutlich kürzer sind als Einzelfälle, sollte die Länge so gewählt werden, dass 95 % der Eingaben ohne Interaktion vollständig gelesen werden können.
Die Mindesthöhe eines Eingabefelds von 44px darf nicht unterschritten werden, um die Barrierefreiheit von <<eingabefeld-mit-button,Input-Optionen>> zu gewährleisten.

Die Schriftgröße von Labeln, Platzhaltern und Hinweistexten sollte 14pt nicht unterschreiten.
Der Abstand eines Eingabefelds zum darunter liegenden Label eines weiteren Eingabefelds soll ca. dem doppelten Abstand zwischen einem Label-Eingabefeld-Paar entsprechen, um eine eindeutige Zuordnung zu gewährleisten.

*_Dos:_*

* Die unmittelbare Nähe der <<label,Labels>> zu den dazugehörigen <<bedienelemente,Bedienelementen>> verbessert die visuelle Verbindung und ermöglicht es den Nutzenden, <<formulare>> schneller und effizienter auszufüllen.
* Gleichmäßige Feldlängen unterstützen den Lesefluss der Nutzenden.
* Die Feldlängen sollten erwartungskonform gewählt werden.
Soll zum Beispiel eine Postleitzahl innerhalb Deutschlands eingegeben werden, so ist es sinnvoll, die Feldlänge auf fünf Stellen zu begrenzen.
Optisch kann das Eingabefeld der Konsistenz entsprechend länger sein.
* Pflichtfelder werden mit einem Asterisk (*) gekennzeichnet.

*_Don'ts:_*

* Labels enden nicht mit einem Doppelpunkt.
* Bei sehr langen Labels sollten sinnvolle Abkürzungen verwendet werden.

[[eingabefeld-mit-mask]]
==== Eingabefeld mit Mask-Option

Um das erwartete Eingabeformat von Eingabefeldern anzuzeigen und als Bedienhilfe die Fehlerwahrscheinlichkeit zu minimieren, werden Masks verwendet.

[[image-eingabefeldmask]]
.Eingabefeld und Mask
image::24_BE_eingabefeld_mask.png[align="center"]

oder

[[image_eingabefeldmask-bold]]
.Eingabefeld und Mask mit "bold"-Label
image::24_BE_eingabefeld_bold_mask.png[align="center"]

Eine Mask kann nur im aktiven State angezeigt werden und entspricht der regulären Schriftfarbe.
Die Mask ist dem erwarteten Inhalt entsprechend fachlich logisch und nachvollziehbar gewählt.
Zum Beispiel entspricht „mobile number“ dem Pattern: +0012 345 / 678 999 oder Ländervorwahl, Vorwahl, Rufnummer.
Masks können dabei auch frei gestaltet und den fachlichen Bedürfnissen entsprechend angepasst werden, beispielsweise für Aktenzeichen.
Eine Mask kann in Einzelfällen auch dem Platzhalter entsprechen.

[[eingabefeld-mit-button]]
==== Eingabefeld mit Input-Option

Für häufig verwendete Eingaben gibt es die Möglichkeit Input-Optionen für das Eingabefeld anzeigen zu lassen.
Dies erleichtert den Nutzenden die Eingabe von festgelegten Formaten, beispielsweise die Eingabe eines Datums bei einem Date-Picker oder die Sicherstellung besonderer Zeichen beim "Sonderzeichenpicker".

[[image-eingabefeldinputoption-sonderzeichen]]
.Eingabefeld und Input-Option Sonderzeichen
image::24_BE_eingabefeld_input_full.png[align="center"]

oder

[[image-eingabefeldinputoption_bold-sonderzeichen]]
.Eingabefeld und Input-Option Sonderzeichen mit "bold"-Label
image::24_BE_eingabefeld_bold_input_full.png[align="center"]

Ein Eingabefeld mit Input-Option ist von der Basis identisch zu einem <<image-eingabefeldplatzhalter,normalen Eingabefeld>>.
Allerdings gibt es am rechten, äußeren Ende des Eingabefelds eine Schaltfläche, um eine Eingabeoption zu aktivieren, zum Beispiel einen Sonderzeichen-Picker (zu sehen in der Abbildung <<image-eingabefeldinputoption>>) oder eine Datumseingabe.
Die Schaltfläche der Input-Option ist mindestens 44px x 44px.

*_Date-Picker_* *WiP*

*_Time-Picker_* *WiP*

*_Sonderzeichen-Picker_*

Der Sonderzeichen-Picker ist eine Input-Option, um nicht übliche Zeichen ohne weitere Hilfsmittel eingeben zu können.
Die Input-Option des Sonderzeichen-Picker ist immer am Ende eines Eingabefelds und entweder vollständig ausgefüllt mit der Primärfarbe oder alternativ im "Outline"-Styling (siehe folgende Abbildungen).

[[image-eingabefeldinputoption-full]]
.Eingabefeld und Input-Option Sonderzeichen
image::24_BE_eingabefeld_input_full.png[align="center"]

oder

[[image-eingabefeldinputoption-bold-full]]
.Eingabefeld und Input-Option Sonderzeichen mit "bold"-Label
image::24_BE_eingabefeld_bold_input_full.png[align="center"]

Alternativ:

[[image-eingabefeldinputoption]]
.Eingabefeld und Input-Option Sonderzeichen im "Outline"-Style
image::24_BE_eingabefeld_input.png[align="center"]

oder

[[image-eingabefeldinputoption_bold]]
.Eingabefeld und Input-Option Sonderzeichen mit "bold"-Label im "Outline"-Style
image::24_BE_eingabefeld_bold_input.png[align="center"]

Beim Klick auf die Input-Option öffnet sich in der Mitte des Frontends der Sonderzeichenpicker als Overlay.

[[image_sonderzeichenpicker]]
.Sonderzeichen-Picker
image::24_BE_sonderzeichenpicker.png[align="center"]

Mit dem Sonderzeichenpicker lässt sich nun ein Sonderzeichen wählen und einfügen.

[[textbox]]
==== Textbox

Eingabefelder können auch eine unbestimmte Menge an Zeichen erwarten.
Dann wird von einer Textbox gesprochen.
Diese unterscheiden sich in der Größe und Form von gewöhnlichen <<eingabefeld,Eingabefeldern>>.

[[image-textbox]]
.Textbox
image::24_BE_Textbox.png[align="center"]

Bei der Eingabe von Text können Textboxen manuell in ihrer Größe verändert werden, sodass der gesamte Inhalt angezeigt werden kann.
Textboxen sollten mindestens so groß gestaltet werden, dass der am häufigsten zu erwartende Inhalt hineinpasst, ohne manuell die Box anzupassen.

[TIP]
Textboxen haben die gleichen States und Styles wie Eingabefelder.

[[liste]]
=== Liste

Listen sind zentrale Bestandteile in Frontends und insbesondere von Fachanwendungen.
Sie dienen dazu, Inhalte zu strukturieren und erfassbar zu machen.
Listen ermöglichen es Nutzenden, zulässige Werte auszuwählen.
Dadurch werden Fehleingaben und unerwartete Ergebnisse reduziert.

Listen bestehen optisch aus einem geschlossenen Rahmen und bestenfalls aus logisch sortierten Elementen.

Listen können in den verschiedensten Ausprägungen eingesetzt werden:

* Eingabefeld + Liste
* Eingabefeld + Suchbox + Liste
* Menüitem + Liste
* etc.

Die einfachste Form einer Liste ist die rein textuelle Liste.

[[image-liste]]
.Einfache Liste
image::24_BE_liste.png[align="center"]

Eine Liste kann theoretisch beliebig viele Einträge enthalten, was aber die <<usability-und-benutzerfreundlichkeit,Usability>> verschlechtert.
Im optimalen Fall haben Listen eine überschaubare Anzahl an logisch relevanten Einträgen.
Die Einträge sind eindeutig und prägnant.
Bei langen Einträgen können auch sinnvolle Abkürzungen genutzt werden.

Die Listenelemente sind mindestens 44px hoch und entsprechend dem dazugehörigen Element breit (hier exemplarisch das Eingabefeld).
Aktive Elemente sind in der Highlightfarbe und hinterlegt dargestellt.

*_Dos_*

* Listen sollen inhaltlich so einfach wie möglich gestaltet werden.
* Listeneinträge sollten so kurz wie möglich formuliert sein.
* Listeneinträge sind eindeutig unterscheidbar.
* Wenn Listen viele Einträge haben, so sollten andere Elemente die Durchsuchbarkeit, Filterung oder Kategorisierung ermöglichen.
* Listen können mit unterschiedlichen interaktiven Elementen kombiniert werden, um den Nutzenden eine Hilfestellung zu bieten.
* Bei einer kleinen Liste kann auch eine Radio-Button-Gruppe genutzt werden.

*_Don'ts_*

* Listeneinträge sollten nie mehrzeilig sein.
* Listeneinträge sollten nicht doppelt vorhanden sein.
* Listen sollten nicht unsortiert und sehr lang sein.
* Listeneinträge mit ganzen Sätzen sollten, wenn möglich, vermieden werden.

[[checkbox]]
=== Checkbox

Checkboxen ermöglichen es Nutzenden, *mehrere* Optionen aus einer (offenen) Liste auszuwählen und spielen eine wichtige Rolle bei der Interaktivität und Benutzerführung.
Der gezielte Einsatz von Checkboxen bei kurzen Listen gibt den Nutzenden die Möglichkeit, die Optionen schnell zu erkennen und auszufüllen.

Checkboxen können auch alleinstehend als boolean-Wert genutzt werden (zum Beispiel, um das Lesen der AGB zu bestätigen).

[[image-checkboxen]]
.Checkboxen
image::24_BE_checkboxen.png[align="center"]

Checkboxen sind 24px x 24px groß und weisen für mobile Geräte mindestens einen 44px x 44px großen Klickbereich (Click-Target-Area) auf.
Checkboxen haben immer ein rechtsstehendes Label mit einer Schriftgröße von mindestens 14pt (hier exemplarisch 16pt).

Eine Checkbox repräsentiert eine unabhängige, nicht-exklusive Auswahl, bei der die Nutzenden beliebig viele Optionen auswählen können.
Dabei können Checkboxen vertikal oder auch horizontal angeordnet werden.

[[image-checkboxen-vertikal]]
.Vertikale Gruppe von Checkboxen
image::24_BE_checkboxen_vertikal.png[align="center"]

[[image-checkboxen-horizontal]]
.Horizontale Gruppe von Checkboxen
image::24_BE_checkboxen_horizontal.png[align="center"]

Wichtig ist, dass jede Checkbox einem Label zugeordnet ist.
Für eine homogene Darstellung sind folgende Abstände einzuhalten:

[[image-checkboxen-mit-einheiten]]
.Vermaßung von Checkboxen horizontal und vertikal
image::24_BE_checkboxen_measured.png[align="center"]

*_Dos_*

* Das Ein- oder Ausschalten einer Checkbox kann dazu genutzt werden, andere Elemente dynamisch zu aktivieren/anzuzeigen oder zu deaktivieren/unsichtbar zu machen.
Zum Beispiel können Eingabefelder eingeblendet werden, wenn per Checkbox "Abweichende Lieferadresse" ausgewählt wird.
* Nicht nur die Box und Target-Area, sondern auch das Label sollten anklickbar sein.
* Eine Gruppe von Checkboxen sollte immer eine Beschriftung aufweisen.
Bei einer einzelnen Checkbox kann diese entfallen.
* Für optimale Lesbarkeit sollten Checkboxen untereinander angeordnet sein.
* Bei Checkboxen mit mehreren Ebenen gilt:
** Solange die Werte der untergeordneten Optionen gleich sind (alle „Aus“ oder alle „An“), zeigt dies die übergeordnete Checkbox mit dem entsprechenden Wert an.
** Sind die Werte der untergeordneten Optionen jedoch nicht mehr homogen gesetzt, so schaltet die übergeordnete Checkbox in den Zustand „nicht definiert“.
Dieser Zustand wird häufig mit einem Quadrat innerhalb der Checkbox symbolisiert.

*_Don'ts_*

* Checkboxen sind kein alleinstehender Ein- und Aus-Schalter, dafür gibt es die Komponente _<<input-switch>>_.
* Eine Checkbox soll keine Funktionen (drucken, speichern, etc.) auslösen oder Seiten öffnen/verlinken.

[[radiobutton]]
=== Radiobutton

Radiobuttons ermöglichen es Nutzenden, *eine* Option aus einer (offenen) Liste auszuwählen und spielen eine wichtige Rolle bei der Interaktivität und Benutzerführung.
Beim Einsatz von Radiobuttons wird den Nutzenden sehr schnell gezeigt, dass sie sich zwischen allen Optionen für eine entscheiden müssen.

Radiobuttons können nicht alleine verwendet werden, da sie nicht wieder abwählbar sind.

[[image-radiobutton]]
.Radiobuttons
image::24_BE_radiobutton.png[align="center"]

Radiobuttons sind 24px groß und weisen für mobile Geräte mindestens einen 44px x 44px großen Klickbereich (Click-Target-Area) auf.
Radiobuttons haben immer ein rechtsstehendes Label mit einer Schriftgröße von mindestens 14pt (hier exemplarisch 16pt).

Ein Radiobutton repräsentiert eine exklusive Auswahl.
Es kann innerhalb der Gruppe genau eine Option ausgewählt werden.
Dabei können Radiobuttons vertikal oder horizontal angeordnet werden.

[[image-radiobutton-vertikal]]
.Vertikale Gruppe von Radiobuttons
image::24_BE_radiobutton_vertikal.png[align="center"]

[[image-radiobutton-horizontal]]
.Horizontale Gruppe von Radiobuttons
image::24_BE_radiobutton_horizontal.png[align="center"]

Wichtig ist, dass jeder Radiobutton einem Label zugeordnet ist.
Für eine homogene Darstellung sind folgende Abstände einzuhalten:

[[image-radiobutton-mit-einheiten]]
.Vermaßung von Radiobuttons horizontal und vertikal
image::24_BE_radiobutton_measured.png[align="center"]

*_Dos_*

* Die Verwendung von Radiobuttons empfiehlt sich für eine kleinere Anzahl an Optionen.
Ist die Menge der zur Verfügung stehenden Optionen sehr groß oder hat der Platzbedarf eine große Bedeutung, so kann der Einsatz eines <<dropdown,Dropdowns>> in Betracht gezogen werden.
* Eine Gruppe von Radiobuttons sollte immer eine Beschriftung aufweisen.
* Für optimale Lesbarkeit sollten Radiobuttons untereinander angeordnet sein.
* Falls alle oder keine der angebotenen Optionen zutreffen können, sollte eine zusätzliche allgemeine Meta-Option, zum Beispiel "keine Option" oder "alle", hinzugefügt werden.

*_Don't_*

Ein Radiobutton darf nicht genutzt werden, um unmittelbar Funktionen auszuführen oder Aktionen auszulösen.
Für diese Zwecke sollten <<button,Buttons>> verwendet werden.

[[input-switch]]
=== Input Switch

Ein Input Switch, auch Eingabeschalter genannt, kommt zum Einsatz, wenn eine bestimmte Funktion oder Eigenschaft ein- und ausgeschaltet werden muss.
Per Default ist immer ein Wert gesetzt: inaktiv (ausgeschaltet) oder aktiv (eingeschaltet).

Um den Nutzenden zu vermitteln welche Funktion oder Eigenschaft ein- beziehungsweise ausgeschaltet werden kann, sollte ein <<label>> links oder rechts neben dem Input Switch platziert werden.
Das verwendete Label sollte aussagekräftig und eindeutig sein.

[[image-inputswitch]]
.Input Switch
image::24_BE_Input_Switch.png[align="center"]

*_Dos_*

* Ein Input Switch wird zum Ein- und Ausschalten von Funktionen oder Eigenschaften benutzt.
* Die Funktion sollte eindeutig benannt werden (zum Beispiel: Zeige ausgeblendete Felder).

*_Don'ts_*

* Input Switches sollten nicht bei mehr als einer Option gewählt werden.
* Input Switches sollten nicht in Sätze eingebaut werden.
* <<checkbox,Checkboxen>> und Input Switches sollen nicht zusammen genutzt werden.
Eine Kombination aus beiden <<bedienelemente,Bedienelementen>> zum Ein- und Ausschalten von Funktionalitäten ist nicht intuitiv für Nutzende.

[[tabview]]
=== Tabview

Ein Tabview ist ein wesentliches Element im modernen Design, das die Benutzererfahrung erheblich verbessert.
Es bietet eine intuitive Möglichkeit, verschiedene Inhalte oder Abschnitte eines Frontends übersichtlich und platzsparend darzustellen.
Durch die Verwendung von Tabs können Nutzende schnell und einfach zwischen verschiedenen Bereichen navigieren, ohne die Seite ständig neu laden zu müssen.
Dies fördert nicht nur die Benutzerfreundlichkeit, sondern auch die Effizienz bei der Informationssuche.
Tabviews ermöglichen Entwickelnden, Inhalte logisch zu organisieren und sorgen für eine klare Struktur, die die Benutzerbindung und Zufriedenheit steigert.

[[image-tabview]]
.Tabview
image::24_BE_tabmenu.png[align="center"]

Ein Tabview hat initial einen aktivierten, aber nicht markierten/fokussierten State (siehe <<image-tabview>>).
Sobald ein Tab aktiv ausgewählt wird, wird auch die Markierung im Reiter visuell deutlich.
Der aktive Tab erhält eine 3px dicke Markierungslinie und ein gefärbtes Label in der Highlightfarbe (hier exemplarisch Blau).

[[image-tabview-active]]
.Tabview mit aktivem Reiter
image::24_BE_tabmenu_active.png[align="center"]

Tabviews können ihre Reiter auch mit visuellen <<icons>> unterstützen.
Diese verhalten sich analog zum Tab-Label.

[[image-tabview-mit-icons]]
.Tabview mit Icons und aktivem Reiter
image::24_BE_tabmenu_icon.png[align="center"]

Es ist ratsam ein Tabview zu nutzen, wenn der Inhalt nicht ohne starkes Scrolling innerhalb des Screens dargestellt werden kann.
Dabei ist eine fachlich logische Aufgliederung vorauszusetzen.

Sollte es fachlich zwingend notwendig sein, mehr Tabs anzubieten, so kann technisch ein „TabOverflow“ via Scrolling eingesetzt werden.
Dieses Element ist ein „Überlängen-Tabview“.

[[image-tabview-overlong]]
.Initiales Aussehen eines Überlängen-Tabview
image::24_BE_tabmenu_long1.png[align="center"]

Das Tabview nutzt dabei die volle, ihm zur Verfügung stehende Breite und graut (faded) den letzten sichtbaren Menüpunkt aus.
Darüber liegt ein Pfeil, der es ermöglicht, zu den nächsten Tabs zu gelangen.
Wurde dieser angeklickt, so springt das Tabview entsprechend viele Einträge weiter.

[[image-tabview-overlong-skipped]]
.Überlängen-Tabview mit mindestens einem Seitensprung
image::24_BE_tabmenu_long2.png[align="center"]

Die Schriftgröße eines Labels im Tabview sollte 14pt nicht unterschreiten.
Ist die Standardschriftgröße gewählt, so erhöht sich diese bei aktiven Elementen um 2pt (hier exemplarisch auf 16pt).
Die Höhe eines Tabreiters ist mindestens 44px.
Die Breite ist abhängig vom <<label>>.
Icons sind mindestens 17px x 17px groß.

[[image-tabview-measured]]
.Exemplarische Vermaßung des Tabview
image::24_BE_tabmenu_measured.png[align="center"]

*_Dos:_*

* Tabs werden eingesetzt, wenn die Komplexität der UI reduziert werden soll und eine sinnvolle Gruppierung einzelner Bereiche vorgenommen werden kann.
* Die optimale Anzahl an Tabs ist 4 – 7.
* Labels für die Tabreiter sollten kurz und aussagekräftig sein.
Es kann auch mit sinnvollen und verständlichen Abkürzungen gearbeitet werden.
* Überlängen-Tabview sollten nur genutzt werden, wenn es keine andere Möglichkeit zur Gestaltung gibt.

*_Don'ts:_*

* Seiten sollten nicht mit nur einem Tabreiter gestaltet werden.
Bei weniger als drei Tabreitern, ist eventuell ein dynamisches <<panel>> das passendere Element.
* Muss der Inhalt verschiedener Tabreiter verglichen/abgestimmt werden, sollte anstelle eines Tabreiters lieber ein dynamisches Panel verwendet werden.
* Tabreiter stellen nicht verschiedene Sichten zu gleichen Daten dar.
* Tabreiter sind keine Prozessschritte.
Für diesen Zweck wird ein Wizard genutzt.
* Tabreiter sollen keine Abhängigkeiten untereinander haben.
* Labels, die länger als 26 Zeichen sind, sollten nicht genutzt werden.

[[tabelle]]
=== Tabelle

Eine Tabelle dient der übersichtlichen Anzeige von größeren Datenmengen und besteht aus mehreren Spalten, die zur Sortierung verwendet werden können.

[[image-tabelle]]
.Beispiel Tabelle
image::24_BE_Tabelle.png[align="center"]

Tabellenzeilen sind standardmäßig nicht anwählbar, was aber durch eine fachliche Notwendigkeit umgesetzt werden kann.
So steht es der Anwendung frei:

* Keine Zeile auswählbar zu machen.
* Eine Zeile mit Klick auswählbar zu machen.
* Eine Zeile mit Doppelklick, zum Beispiel direkt in der Detailansicht, zu öffnen.
* Eine Zeile mit einer Spalte und Checkbox auswählbar zu machen.

[IMPORTANT]
Es ist wichtig, das Verhalten von Tabellen innerhalb der Anwendung konsistent zu halten.
Unterschiedliches Verhalten von Tabellen ist *NICHT* zulässig!

Wenn mehrere Aktionen für eine Tabellenzeile erfolgen können, dann werden Folgeaktionen über Aktionselemente in der letzten Spalte "Aktionen" bereitgestellt.
Falls eine Doppelklick-Aktion in einer Zeile implementiert wird, sollte dies die primäre Funktion der möglichen Tabellenzeilen-Aktionen sein.

* Doppelklick = Detailansicht öffnen; folglich ist die erste/primäre Aktion = "Detailansicht öffnen".
* Die aktive/fokussierte Zeile hat die Primärfarbe und der Hover entspricht dem PrimeNG Standard.

*_Dos:_*

* Tabellen werden genutzt, um große Mengen von Daten oder Objekten anzuzeigen.
* Tabellen sollten übersichtlich bleiben.
Weniger wichtige Spalten können ausgeblendet werden.
Es ist nicht zielführend alle Daten anzuzeigen.
Die Fachlichkeit sollte sich auf eine Teilmenge von wichtigen Informationen beschränken.
* Überlaufende Textlabels werden abgetrennt und mit einem Tooltip ergänzt.
* Spaltentitel sollten so kurz wie möglich und prägnant gewählt werden.
Abkürzungen sind zulässig.
* Die initiale oder maximale Breite von Spalten muss sich an den zu erwartenden Inhalten orientieren, auch wenn der Spaltentitel dadurch abgeschnitten wird (es gibt keine feste maximale Buchstabenanzahl).
* Tabellenspalten können unterschiedlich breit sein.
* Vertikales Scrolling ist zu vermeiden.
* Die Spalten sollten ihrer Wichtigkeit nach angeordnet werden.
* Tabellen sollten nach Möglichkeit maximal 20 Zeilen anzeigen und dann eine Paginierung nutzen.
Sollte es fachlich notwendig sein, kann auch endless-scrolling eingesetzt werden.
* <<icons,Symbole>> und <<grafiken,Bilder>> können zur schnelleren visuellen Unterscheidung von Listeneinträgen genutzt werden.

*_Don'ts:_*

* Es sollten keine Tabellen mit nur 1-2 Spalten erzeugt werden.
* Bei Tabellen sollte nicht vertikal gescrollt werden.
* Wenn nur ein einziger Eintrag länger ist als der Durchschnitt, sollte sich die Breite der Spalten nicht nach diesem Eintrag richten.
* Wenn sich Symbole oder Bilder nur wiederholen, sollte auf sie verzichtet werden.

[[sortierung-tabelle]]
==== Sortierung

Tabellen sollten aufgrund ihrer großen Datenmengen pro Spalte sortierbar sein und eine auf- und absteigende Sortierung anbieten (zwei Pfeile im Tabellenheader).
Der Klickbereich des Icons ist dabei 44px x 44px groß (siehe <<image-tabelle>>).

* Der erste Klick auf die Sortiericons sortiert die Tabelle nach den Werten in der gewählten Spalte aufsteigend.
* Ein zweiter Klick auf die Sortiericons sortiert die Tabelle entsprechend absteigend.
* Das wechselnde Icon zeigt die aktuelle Sortierung an.

[[filterung-tabelle]]
==== Filterung

Es bietet sich an, dass Tabellen auch filterbar gestaltet werden.
Dafür können verschiedene fachliche Filter definiert werden.
Die Filter lassen sich in beliebiger Weise kombinieren.
Über den übergeordneten <<icon-button>> "Löschen" werden alle Filter gelöscht und die Tabelle aktualisiert.

* Eine Spalte kann mehrere Filter anwenden.
* Filter sind nur pro Spalte gültig.
* Es können gleichzeitig mehrere Filter auf unterschiedliche Spalten angewendet werden.
* Filter werden sofort nach Auswahl angewandt (Aktualisierung der Tabelle).
* Aktive Filter sollten deutlich erkennbar sein.

[[selektionsverhalten-tabelle]]
==== Selektionsverhalten

Es gibt verschiedene Möglichkeiten, ein Element in einer Tabelle zu selektieren.
Dabei ist die notwendige Fachlichkeit maßgeblich für das Verhalten verantwortlich.

Es kann vorkommen, dass es in einer Anwendung sinnvoll ist, große Datenmengen auszuwählen und dass es in einer anderen Anwendung wiederum besser ist, gar keine Auswahl zuzulassen.
Grundsätzlich gilt, dass ausgewählte Zeilen farbig hinterlegt werden müssen.
Alle nachfolgenden Punkte sind Möglichkeiten, die eingesetzt werden *können*.
Sollte ein entsprechendes Verhalten angewendet werden, so ist darauf zu achten, dass sich alle Tabellen in der Anwendung konsistent verhalten.

* Die Kennzeichnung eines Objektes (Name, ID, etc.) kann als Link zur Navigation genutzt werden, um weitere Details anzuzeigen.
* Der Doppelklick auf eine Zeile kann zum Beispiel die Details eines Elements öffnen.
* Die erste Zeile kann per Default selektiert werden.

[[bigdata-tabelle]]
==== Große Datenmengen

Tabellen können sehr viele Daten enthalten und gegebenenfalls sehr lang werden.
Um den Umgang mit solchen Tabellen zu vereinfachen, sollten nicht alle Daten initial in der Tabelle angezeigt werden.
Über einen Paginator, Endless Scrolling oder einen "Mehr anzeigen"-Button können Nutzende sich bei Bedarf mehr Daten anzeigen lassen.

*_Paginator_*

* Der Paginator wird nach 5, 10 oder 20 Zeilen am Ende der Tabelle angezeigt.
* Der Paginator erlaubt es, die nächste Seite aber auch weiter entfernte Seiten auszuwählen.
* Der Paginator zeigt immer den Stand der angezeigten Menge an (zum Beispiel: "1-10").
* Der Paginator bietet die Möglichkeit ganz ans Ende oder ganz an den Anfang zu springen.

[[image-initial-paginator]]
.Initialer Paginator
image::24_DP_Initial_paginator.png[align="center"]

[[image-active-paginator]]
.Aktive Auswahl am Paginator (Seite 5 ausgewählt)
image::24_DP_active-item_paginator.png[align="center"]

*_Endless Scrolling_*

* Die Tabelle wird initial mit den ersten 10 oder 20 Zeilen angezeigt.
* Standardmäßig erscheint eine Scrollbar und beim Scrollen werden nach und nach weitere Zeilen eingeblendet, während die oberen Zeilen aus dem View verschwinden.

[NOTE]
Es kann Lazy Loading verwendet werden.

*_"Mehr anzeigen"-Button_*

* Die Tabelle wird initial mit den ersten 10 oder 20 Zeilen angezeigt.
* Nach einem Klick auf den "Mehr anzeigen"-Button werden die nächsten 9 oder 19 Items nachgeladen.
Dadurch soll erkenntlich sein, dass es genau am Ende des letzten Eintrags weitergeht.

[[design-pattern]]
== Design Patterns

Design Patterns beschreiben wiederkehrende und bewährte Lösungsansätze für Interaktions- und Darstellungsanforderungen.
Sie erstrecken sich über mehrere Komponenten und Bereiche des Frontends und stellen sicher, dass vergleichbare Nutzungssituationen konsistent, barrierefrei und technologiekompatibel umgesetzt werden.
Sie bilden die verbindliche Grundlage für die einheitliche Gestaltung und Interaktion innerhalb der Anwendung.

[[primaere-fenstertypen]]
=== Primäre Fenstertypen

Primäre Fenstertypen (Seitentypen) beschreiben die regulären, dauerhaft verfügbaren Arbeitsansichten im Hauptfenster der Anwendung.
Sie definieren den kontextbezogenen Darstellungsrahmen einschließlich des funktionalen und visuellen Verhaltens für wiederkehrende Seitenlayouts.

In ihrer Gesamtheit bilden die Seitentypen die verbindliche Strukturierungsgrundlage für sämtliche Ansichten im Hauptfenster.
Sie sind so zu gestalten, dass die Anforderungen aus Kapitel <<barrierefreiheit>> sowie die in Kapitel <<fenstertypen-layout>> definierten Prinzipien (u. a. Struktur, Reflow, Fokusführung, Raster) eingehalten werden.
Die nachfolgend beschriebenen Festlegungen zu den einzelnen Seitentypen sind verbindlich anzuwenden.

Die technische Umsetzung der Seitentypen orientiert sich an Angular sowie PrimeNG/PrimeFlex.
Genannte Komponenten (z. B. `p-card`, `p-grid`, `p-toolbar`, `p-button`, `p-toast`) dienen als Referenz für Interaktions- und Anzeigeverhalten.
Gleichwertige Implementierungen sind zulässig, sofern sämtliche Anforderungen dieses Kapitels eingehalten werden.

Die nachfolgenden Abschnitte konkretisieren Aufbau, Inhalte und Interaktionsverhalten der einzelnen Seitentypen.

[[login]]
==== Login

Der Login stellt den initialen Zugang zur Fachanwendung bereit.
Er muss eine reibungsarme, klare und barrierefreie Interaktion gewährleisten.
Überholte Gestaltungsformen (z. B. starre rechte Spalten, leere Zierspalten, generische Allzweckdialoge) dürfen nicht verwendet werden.

{empty} +

[[image-loginscreen]]
.Login Screen
image::01_Login.png[align="center", width="629", height="528"]

{empty} +

*_Layout und Struktur_*

[[r-login-ohne-hauptnavigation]]
* *Header:* Der Header ist ohne Hauptnavigation darzustellen.
  Aufbau, Landmark-Struktur und Fokusverhalten haben den allgemeinen Vorgaben des <<header-bereich>> zu entsprechen.
  Die visuelle Höhe ist konsistent zu halten.

[[r-login-zentrierte-card]]
* *Seitenrahmen:* Der Seitenrahmen stellt einen zentrierten Login-Bereich in einem responsiven, flexibel skalierenden Container bereit (z. B. mit definierter Maximalbreite).
  Künstliche Leerspalten oder zusätzliche Layoutspalten dürfen nicht entstehen.

[[r-login-reflow-ohne-xscroll]]
* *Responsives Verhalten:* Die Login-Seite ist durchgängig einspaltig auszuführen.
  Login-Formular und zugehörige Inhalte sind in einer vertikalen Inhaltsachse untereinander anzuordnen.
  Im definierten Zielkorridor (z. B. Smartphone-Breiten) erfolgt eine einspaltige Darstellung ohne horizontales Scrollen.

[[r-login-hilfe-kontakt]]
* *Hilfe & Kontakt:* Hinweise zu Hilfe und Support sind unterhalb des Login-Formulars entweder als kompakter Support-Block oder über einen „Hilfe & Kontakt“-Expander bereitzustellen.
  Sie sind damit Teil des linearen Inhaltsflusses.
  Eine feste rechte Spalte für Hilfe-, Support- oder andere funktionale Inhalte ist unzulässig.

*_Formular und Eingabefelder_*

[[r-login-felder-autocomplete]]
* *Felder:* Das Login-Formular stellt mindestens die Felder *Benutzername* (`autocomplete="username"`) und *Passwort* (`autocomplete="current-password"`) bereit. 
  Optionale Ergänzungen wie „Angemeldet bleiben“ und „Passwort vergessen?“ sind zulässig.

[[r-login-validierung-inline-global]]
* *Validierung:* Fehlermeldungen sind feldnah, in unmittelbarer Nähe zum jeweils betroffenen Eingabefeld, anzuzeigen.
  Zusätzlich ist eine globale Meldungszone (z. B. „Login fehlgeschlagen“) bereitzustellen.
  Die Darstellung von Fehlermeldungen darf keine unerwarteten Layoutsprünge verursachen.

[[r-login-passwortmanager]]
* *Passwortmanager:* Einfügen (Paste) und Autofill sind zuzulassen.
  Der Schalter „Passwort anzeigen“ ist vollständig tastaturbedienbar so zu implementieren, dass Name, Rolle und Wert programmgesteuert ermittelbar sind.
  Details siehe Kapitel <<bedienelemente>>.

[[dashboard]]
==== Dashboard

Das Dashboard dient als zentraler Einstieg nach dem Login.
Es bietet eine barrierefreie, rollen- und kontextbasierte Übersicht über verfügbare Applikationen.
Die Gestaltung muss eine schnelle Orientierung, klare Navigierbarkeit und eine effiziente Wiederaufnahme von Aufgaben gewährleisten.

{empty} +

[[image-dashboard]]
.Dashboard
image::02_Dashboard.png[align="center", width="629", height="528"]

[[image-aufbau-dashboard]]
.Aufbau Dashboard
image::Aufbau-Dashboard.png[align="center", width="629", height="526"]

{empty} +

*_Aufbau_*

[[r-dashboard-headerbereich]]
* *Headerbereich:* Der Aufbau entspricht vollständig dem definierten <<header-bereich>>.

[[r-dashboard-inhaltsbereich]]
* *Inhaltsbereich:* Der Inhaltsbereich ist in drei Teilbereiche zu strukturieren:
  ** Quicklinks (*A*)
  ** Applikationen-Widgets (*B*)
  ** Informationen (*C*)

*_Richtlinien zur Anwendung (alle Teilbereiche)_*

[[r-dashboard-grid]]
* *Responsives Grid:* Die Teilbereiche ordnen sich im 3→2→1-Raster an.
  Horizontales Scrollen ist auszuschließen (vgl. <<layout-resizing>>).

[[r-dashboard-relevanz]]
* *Relevanz & Personalisierung:* Inhalte sind rollen- und kontextabhängig bereitzustellen.
  Irrelevante Elemente dürfen nicht angezeigt werden.

[[r-dashboard-widget-prinzip]]
* *Widget-Prinzip:* Ein Widget repräsentiert genau einen Inhaltstyp.
  Es enthält einen Titel, optional ein Icon und klare Aktionen.
  Widgets sind als Landmark (`role="region"` mit `aria-labelledby`) auszuzeichnen.

[[r-dashboard-zustaende]]
* *Zustände und Größenverhalten:* Die Höhe eines Widgets passt sich dem Inhalt an.
  Leer-, Lade- und Fehlerzustände sind stabil ausgeprägt (Skeleton/Spinner, klare Meldung, Retry).
  Layoutsprünge dürfen nicht auftreten.

[[r-dashboard-lesereihenfolge]]
* *Lesereihenfolge:* Die Lesereihenfolge entspricht der visuellen Darstellung (A → B → C).
  Auf schmalen Viewports erfolgt eine lineare Untereinander-Anordnung.

[[r-dashboard-modalarm]]
* *Modalarme Interaktionen:* Bestätigungen sind bevorzugt inline bereitzustellen, ergänzt durch Undo-Optionen (Toast).
  Blockierende Modaldialoge sind gemäß <<modalarme-interaktionen>> zu begründen und möglichst zu vermeiden.

*_Quicklinks (A)_*

[[r-quicklinks-platzierung]]
* *Platzierung:* Teilbereich *A* liegt auf dem Desktop in der linken bzw. ersten Spalte.
  Auf mobilen Geräten und Tablets wird er oberhalb der Applikations-Widgets dargestellt.

[[r-quicklinks-zweck]]
* *Zweck:* Quicklinks bieten Direkteinstiege zu häufig genutzten Funktionen oder Objekten (z. B. „Wiedervorlagen“, „Abgelegte Vorgänge“, „Häufig benutzte Funktionen“).

[[r-quicklinks-gruppen]]
* *Gruppierung & Umfang:* Quicklinks werden in logischen Gruppen (Widgets) zusammengefasst.
  Pro Gruppe sind in der Regel 5 Links vorzusehen.
  Abweichungen sind zu begründen.

[[r-quicklinks-interaktion]]
* *Interaktion:* Ziele sind im selben Fenster zu öffnen.
  Bestätigungspflichtige Handlungen erfolgen inline.

*_Applikations-Widgets (B)_*

[[r-appwidgets-platzierung]]
* *Platzierung:* Teilbereich *B* liegt auf dem Desktop in der mittleren Spalte.

[[r-appwidgets-zweck]]
* *Zweck:* Applikations-Widgets ermöglichen den Zugang zu Applikationen oder Applikationsgruppen.
  Sie sind als Kacheln/Panels (`p-card`/`p-panel`) mit Titel, optionalem Icon und kurzer Beschreibung darzustellen.

[[r-appwidgets-gruppierung]]
* *Gruppierung:* Applikationen sind thematisch zu bündeln; einzelne Applikationen können eigene Widgets erhalten.

[[r-appwidgets-nav-paritaet]]
* *Nav-Parität:* Links innerhalb eines Widgets entsprechen inhaltlich der Navigationsebene 2 (siehe Kapitel <<navigation>>).

[[r-appwidgets-sichtbarkeit]]
* *Sichtbarkeit:* Die Sichtbarkeit erfolgt rollen- bzw. berechtigungsbasiert.

[[r-appwidgets-kennzeichnung]]
* *Kennzeichnung:* <<applikationsfarben>> und ggf. Applikationsicons sind konsistent einzusetzen.

*_Informationen \(C)_*

[[r-info-platzierung]]
* *Platzierung:* Auf dem Desktop liegt Teilbereich *C* rechts in der dritten Spalte.
  Auf mobilen Geräten ist er unterhalb der Applikations-Widgets anzuordnen.

[[r-info-zweck]]
* *Zweck:* Teilbereich *C* enthält Benachrichtigungen, Benutzerinformationen oder Kontaktangaben.
  Er wird nur angezeigt, wenn entsprechende Inhalte vorliegen.

[[r-info-mehr]]
* *Mehr Inhalte:* Weitere Inhalte sind über „Mehr anzeigen“ auf eine Unterseite auszulagern.

{empty} +

[[image-dashboard-elements]]
.Dashboard-Elemente
image::Dashboard_Elemente.png[align="center", width="629", height="120"]

{empty} +

*_Aufbau der Widgets_*

[[r-dashboard-widgets-typ-ac]]
* *Typ A/C:*
  ** *Strukturelle Anforderungen:* Widgets des Typs A und C müssen eine semantische Überschrift enthalten.
     Die Verwendung eines Icons sowie eines „Mehr“-Links ist optional.

  ** *Darstellung der Links:* Die innerhalb des Widgets bereitgestellten Links sind als Liste mit sichtbarem Textlabel bereitzustellen.
     Der Einsatz von Icons ist optional.

  ** *Konsistenzanforderungen:* Wird in einem Link eine Kombination aus Icon und Text verwendet, ist diese Darstellungsform für sämtliche Links innerhalb desselben Widgets einheitlich anzuwenden.
     Dekorative Icons sind mit `aria-hidden="true"` zu kennzeichnen.

[[r-dashboard-widgets-typ-b]]
* *Typ B:*
  ** *Strukturelle Anforderungen:* Widgets des Typs B müssen folgende Elemente enthalten:
  *** einen Widget-Titel,
  *** die Bezeichnung der Applikationsgruppe oder der Applikation,
  *** optional ein Applikationsicon,
  *** eine Farbmarkierung gemäß den festgelegten <<applikationsfarben>>,
  *** Links zu Unterbereichen bzw. Funktionen (Benennung entsprechend <<navigation,Navigationsebene>> 2).

  ** *Konsistenzanforderungen:* Farbmarkierungen sind pro Applikationsgruppe bzw. Applikation einheitlich einzusetzen.
     Icons derselben Ebene sind konsistent zu gestalten.
     Links müssen in allen Fällen ein sichtbares Textlabel enthalten.

[[dashboard-unterseite]]
==== Dashboard-Unterseite

Die Dashboard-Unterseite stellt weiterführende Informationen bereit, die nicht vollständig auf dem Dashboard dargestellt werden können.

{empty} +

[[image-aufbau-dashboard-subpage]]
.Aufbau Dashboard-Unterseite
image::Aufbau-Dashboard-Unterseite.png[align="center", width="629", height="526"]

{empty} +

*_Aufbau_*

[[r-dsub-headerbereich]]
* *Headerbereich:* Aufbau und Verhalten entsprechen vollständig dem definierten <<header-bereich>>.

[[r-dsub-toolbar]]
* *Seiten-Toolbar:* Kontextfunktionen (z. B. „Zurück zur Übersicht“, „Vorheriges/Nächstes“, „Drucken“, „Hilfe“) sind persistent, konsistent und klar erkennbar bereitzustellen.

[[r-dsub-inhaltsbereich]]
* *Inhaltsbereich:* Inhalte werden in modularen Abschnitten (z. B. Listen, Karten, Tabs, Accordion) gemäß Raster angeordnet.
  Der Umbruch erfolgt responsiv im 3→2→1-Raster; horizontales Scrollen ist auszuschließen (vgl. <<layout-resizing>>).

*_Richtlinien zur Anwendung_*

[[r-dsub-bezug]]
* *Bezug/Orientierung:* Titel, Icon und Farbmarkierung entsprechen der auslösenden Dashboard-Kachel bzw. -Gruppe.

[[r-dsub-navigation]]
* *Navigation:* „Zurück zur Übersicht“ führt zur auslösenden Stelle auf dem Dashboard (ggf. mit Anker).
  Listen bieten eine „Vorheriges/Nächstes“-Navigation innerhalb derselben Treffermenge.

[[r-app-inhalte]]
[[r-dsub-layout]]
* *Layout & Inhalte:* Pro Abschnitt gilt das Ein-Inhaltstyp-Prinzip.
  Für umfangreiche Inhalte können Tabs oder Accordions eingesetzt werden.

[[applikationsseite]]
==== Applikationsseite

Die Applikationsseite bildet den Einstieg in eine Applikation. Sie stellt zentrale Inhalte und Funktionen bereit und führt zu Unterseiten.

{empty} +

[[image-app-page]]
.Abbildung: Applikationsseite (Beispiel)
image::04_Applikationsseite.png[align="center", width="629", height="528"]

[[image-app-page-structure]]
.Aufbau einer Applikationsseite
image::Aufbau-Applikationsseite.png[align="center", width="629", height="526"]

{empty} +

*_Aufbau_*

[[r-app-headerbereich]]
* *Headerbereich:* Aufbau und Verhalten entsprechen vollständig dem definierten <<header-bereich>>.

[[r-app-linksnavigation-aufbau]]
* *Linksnavigation (optional):* Bildet applikationsinterne Bereiche und Funktionsgruppen ab.

[[r-app-inhaltsbereich-aufbau]]
* *Inhaltsbereich:* Applikationsrelevante Inhalte sind in modularen Abschnitten darzustellen.

*_Richtlinien zur Anwendung_*

[[r-app-eigene-seite]]
* *Eigene Applikationsseite:* Jede Applikation muss eine eigenständige Applikationsseite besitzen.

[[r-app-inhalte-variieren]]
* *Inhaltsumfang je Applikation:* Umfang und Struktur sind applikationsspezifisch festzulegen.

[[r-app-linksnavigation]]
* *Optionale Linksnavigation:* Die Applikationsseite kann eine optionale Linksnavigation enthalten (siehe Kapitel <<Linksnavigation>>).

[[r-app-ohne-linksnavigation]]
* *Inhaltsbereich ohne Linksnavigation:* Entfällt die Linksnavigation, nutzt der Inhaltsbereich die gesamte verfügbare Breite.

[[r-app-erkennbarkeit]]
* *Erkennbarkeit der Applikation:* Der Name der Applikation muss eindeutig erkennbar ausgewiesen werden (in der Linksnavigation oder in der ersten Gruppierungsüberschrift des Inhaltsbereichs).

*_Kennzeichnung von Applikationsgruppen/Applikationen_*

Applikationen sind, sofern fachlich möglich, zu Applikationsgruppen zusammenzufassen.
Jede Applikationsgruppe bzw. jede eigenständige Applikation erhält eine eindeutige farbliche Kennzeichnung (Applikationsfarben) und – sofern verwendet – ein konsistentes Applikationsicon.

{empty} +

[[image-farbmarkierung]]
.Dashboard-Widget – Farbmarkierung und Applikationsicon
image::Applikation_Widget.png[align="center", width="343",height="145"]

[[image-farbmarkierungdetail]]
.Farbmarkierung Detailseite und Dialog
image::Applikation_Farbmarkierung.png[align="center", width="629",height="557"]

{empty} +

[[r-app-kennzeichnung]]
*_Richtlinien zur Kennzeichnung_*

[[r-app-kennzeichnung-farbe]]
* *Kennzeichnung über Applikationsfarben:* Jede Applikationsgruppe bzw. jede eigenständige Applikation ist durch eine farbliche Markierung zu kennzeichnen (siehe Kapitel <<applikationsfarben>>).

[[r-app-kennzeichnung-einsatzorte]]
* *Einsatzorte der Farbcodierung:* Die Applikationsfarbe ist an den folgenden Stellen der Anwendung konsistent einzusetzen:
  ** Hauptnavigation – Farbbalken unterhalb des Headers  
  ** Subnavigation (Flyout) – Farbbalken am oberen Rand des Menüs  
  ** Dashboard-Widget – Farbbalken am oberen Rand  
  ** Detailseiten – Hintergrundfarbe der Titelzeile  
  ** Dialoge der Applikation – Farbbalken oberhalb der Titelzeile

[[r-app-kennzeichnung-icon]]
* *Applikationsicon:* Die Verwendung eines Applikationsicons ist optional.
Wird ein Applikationsicon eingesetzt, muss es an allen vorgesehenen Stellen konsistent verwendet werden.

[[r-app-kennzeichnung-icon-einsatzorte]]
* *Einsatzorte des Applikationsicons:* Das Applikationsicon kann an folgenden Stellen eingesetzt werden:
  ** Dashboard-Widget – <<image-farbmarkierung,Farbmarkierung>> + Applikationsicon  
  ** Subnavigation (Flyout) – <<image-applikationsicon,Icon der Applikation>>  
  ** Gruppierungsüberschriften auf Applikationsseiten – <<image-applikationsicon,Icon in Überschriften>>

{empty} +

[[image-applikationsicon]]
.Applikationsicon auf Applikationsseite
image::Applikation_Hauptseite2a.png[align="center", width="627",height="521"]

[[applikations-detailseite]]
==== Applikations-Detailseite

Die Applikations-Detailseite stellt genau ein einzelnes Objekt der Applikation dar und strukturiert dessen Inhalte in Titelzeile, Seiten-Toolbar, Basisdaten, Objektdetails sowie gegebenenfalls einen optionalen Informationsbereich.
Sie dient der eindeutigen Identifikation des Objekts, der gebündelten Bereitstellung objektbezogener Funktionen und der übersichtlichen Darstellung der zugehörigen Informationen.

{empty} +

[[image-applikationdetailbeispiel]]
.Applikation Detailseite – Beispiel
image::Detailseite_Beispiel2a.png[align="center", width="629",height="640"]

[[image-aufbauapplikationdetail]]
.Aufbau Applikation Detailseite
image::aufbauapplikationdetail.png[align="center", width="629",height="526"]

{empty} +

*_Aufbau_*

[[r-detail-headerbereich]]
* *Headerbereich:* Aufbau und Verhalten entsprechen vollständig dem definierten <<header-bereich>>.

* *Titelzeile:* Die Titelzeile benennt Objekt und Kontext eindeutig (siehe <<r-detail-titelzeile,Titelzeile (A)>>) und stellt die fachliche Verortung des Objekts sicher.

* *Seiten-Toolbar:* Die Seiten-Toolbar enthält seitenspezifische Aktionen (z. B. „Zurück zur Liste“, „Bearbeiten“, „Drucken“, „Hilfe“) und ist persistent sowie konsistent bereitzustellen.

[[r-detail-inhaltsbereich]]
* *Inhaltsbereich:* Der Inhaltsbereich stellt den Objektinhalt in Basisdaten (optional) und Objektdetails dar.
  Ein Informationsbereich (optional) kann ein- und ausgeblendet werden.

*_Richtlinien zur Anwendung_*

[[r-detail-titelzeile]]
* *Titelzeile (A):* Die Titelzeile muss aus Varianten von Titel, Headline und einem Kontext-Breadcrumb bestehen (keine History-Breadcrumb).
  Ohne verständlichen, aussagekräftigen Text darf keine Detailseite bereitgestellt werden.
  Der Rücksprung in die auslösende Übersicht erfolgt über die Seiten-Toolbar („Zurück zur Liste“).

** *Beispiele (Struktur):*
*** *2 Ebenen:* _Label Ebene 2_: Objektname / ID
*** *3 Ebenen:* _Label Ebene 2 – Label Ebene 3_: Objektname / ID

[[r-detail-toolbar]]
* *Seiten-Toolbar (B):* Die Seiten-Toolbar muss mindestens die Aktionen „Zurück zur Liste“ (Filter/Pager nach Möglichkeit erhalten), „Drucken“ und „Hilfe“ sowie – sofern vorgesehen – „Bearbeiten / Speichern / Abbrechen“ enthalten.
  Beschriftung und Reihenfolge sind in der gesamten Anwendung konsistent zu halten.
  Die Enter-Taste löst die Primäraktion aus; Esc bricht die aktuelle Aktion ab.

[[r-detail-info]]
* *Informationsbereich (C, optional):*

** *Ein-/Ausblendung:* Der Informationsbereich ist initial ausgeblendet bereitzustellen und kann über einen eindeutig beschrifteten Button in der Seiten-Toolbar ein- und ausgeblendet werden.
** *Inhaltlicher Zweck:* Der Informationsbereich enthält ausschließlich hilfreiche und ergänzende Informationen zum dargestellten Objekttyp und dessen Bearbeitung.
** *Sichtbarkeit:* Informationsbereich und zugehöriger Toolbar-Button sind nur bereitzustellen, wenn tatsächlich relevante ergänzende Inhalte vorhanden sind.
** *Layoutverhalten:* Beim Einblenden verschiebt sich der Inhaltsbereich sichtbar nach unten bzw. zur Seite, ohne Inhalte zu überdecken oder den Fokus zu verdecken.

* *Inhaltsbereich (D):*

** *Objektdetails:* Im Inhaltsbereich werden die Objektdetails angezeigt.
[[r-detail-inhalt-basisdaten]]
** *Kopfdaten (optional):* Der Inhaltsbereich kann Kopfdaten enthalten.
Sie unterstützen Nutzende dabei, wesentliche Informationen komplexer Objekte auf einen Blick zu erfassen und können optional mit einem Expander kombiniert werden, sodass sie bei Bedarf ein- oder ausgeblendet werden können.
[[r-detail-struktur-expander]]
** *Strukturierung:* Umfangreiche Inhalte werden über Gruppierungs-Container und Expander (Progressive Disclosure) sinnvoll gegliedert.
[[r-detail-tabs-accordion]]
** *Tabs/Accordion:* Tabs können eingesetzt werden, um gleichrangige Inhalte zu strukturieren und langes vertikales Scrollen zu vermeiden.
   Accordions/Expander sind für nachgeordnete oder optionale Inhalte vorzusehen.
   Mischformen (Tabs und Accordions) auf derselben Hierarchieebene sind zu vermeiden.

==== Normative Bezüge

[cols="3,2,3", options="header"]
|===
| Anforderung | Normbezug | Akzeptanzkriterium

| <<r-login-zentrierte-card,Zentrierte Login-Card, reflow-fähig>>
| WCAG 1.4.10 / 1.3.2
| Bis 400 %/320 px einspaltig nutzbar; Struktur/Lesereihenfolge bleibt erhalten.

| <<r-login-reflow-ohne-xscroll,Kein X-Scroll im Zielkorridor>>
| WCAG 1.4.10
| Fließtext und Controls ohne horizontales Scrollen nutzbar.

| <<r-login-hilfe-kontakt,Hilfe/Support unter Formular/Expander>>
| WCAG 3.2.6 / 4.1.2
| Hilfe konsistent unter Formular oder im Expander; Expander fokussierbar.

| <<r-login-felder-autocomplete,autocomplete für Benutzername/Passwort>>
| WCAG 1.3.5 / 3.3.8
| Felder mit `autocomplete="username"` / `autocomplete="current-password"`; Passwortmanager funktionieren.

| <<r-login-validierung-inline-global,Fehler feldnah + global, ohne Layoutsprünge>>
| WCAG 3.3.1 / 3.3.3 / 4.1.3
| Fehler feldnah + global verständlich; programmatisch als Statusmeldung erkennbar.

| <<r-login-passwortmanager,„Passwort anzeigen“-Toggle tastaturbedienbar>>
| WCAG 2.1.1 / 3.3.8 / 4.1.2
| Toggle tastaturbedienbar, korrekt benannt; verhindert weder Einfügen noch Autofill.

| <<r-dashboard-grid,Dashboard-Grid 3→2→1, kein X-Scroll>>
| WCAG 1.4.10
| Dashboard reflowt 3→2→1 bis 400 %/320 px; kein horizontales Scrollen.

| <<r-dashboard-widget-prinzip,Widgets als Landmark mit Label>>
| WCAG 1.3.1 / WAI-ARIA 1.2
| Widgets als Landmarks mit aussagekräftigem Namen programmatisch erkennbar.

| <<r-dashboard-lesereihenfolge,Fokus-/Tab-Reihenfolge = Sichtreihenfolge>>
| WCAG 1.3.2 / 2.4.3
| Fokus-/Lesereihenfolge = Sichtreihenfolge; keine unerwarteten Sprünge.

| <<r-dashboard-zustaende,Leere/Lade/Fehler stabil, ohne Layoutsprünge>>
| WCAG 1.4.10 / 4.1.3
| Leer-/Lade-/Fehlerzustände klar als Status erkennbar; keine Layoutsprünge.

| <<r-dashboard-modalarm,Bestätigen/Löschen inline + Undo (Toast)>>
| WCAG 3.3.1 / 3.3.3 / 4.1.3
| Bestätigungen/Fehler inline oder als Toast; nicht-blockierend, verständliche Rückmeldung.

| <<r-dsub-bezug,Unterseite spiegelt Titel/Icon/Farbe der Kachel>>
| WCAG 3.2.4
| Titel/Icon/Farbe kennzeichnen denselben Kontext konsistent.

| <<r-dsub-navigation,„Zurück zur Übersicht“ + Vorheriges/Nächstes>>
| WCAG 2.4.3 / 2.4.5
| Treffermenge seitenweise durchlaufbar; Rückkehr zur Übersicht jederzeit möglich.

| <<r-dsub-layout,Unterseite: Grid 3→2→1, stabile Zustände>>
| WCAG 1.3.1 / 1.4.10
| Inhalte in klaren Abschnitten; 3→2→1-Reflow ohne horizontales Scrollen.

| <<r-app-erkennbarkeit,App-Name prominent/programmatisch erkennbar>>
| WCAG 2.4.6
| App-Name als Überschrift/Label klar wahrnehmbar und programmatisch identifizierbar.

| <<r-app-inhalte,Abschnitte ohne Misch-Widgets; Tabs/Accordion bei Bedarf>>
| WCAG 1.3.1 / 1.4.10
| Pro Abschnitt ein Inhaltstyp; umfangreiche Inhalte via Tabs/Accordion strukturiert.

| <<r-app-kennzeichnung,Farben/Icons konsistent, nicht allein Information>>
| WCAG 1.4.1 / 1.4.11
| Farben/Icons kennzeichnen Apps konsistent; Information nicht nur über Farbe; Nicht-Text-Kontrast erfüllt.

| <<r-detail-titelzeile,Titelzeile Pflicht; Kontext eindeutig>>
| WCAG 2.4.6
| Titelzeile benennt Objekt + Kontext eindeutig; fungiert als Überschrift.

| <<r-detail-toolbar,Toolbar konsistent; Enter/Esc-Konvention>>
| WCAG 2.1.1 / 3.2.3
| Toolbar einheitlich, vollständig tastaturbedienbar; Verhalten appweit konsistent.

| <<r-detail-inhalt-basisdaten,Basisdaten prominent; optional Expander>>
| WCAG 1.3.1
| Basisdaten als eigener Abschnitt ausgezeichnet; erleichtern Erfassen der Kerninfos.

| <<r-detail-tabs-accordion,Tabs für gleichrangig; Accordion für optional>>
| WCAG 1.3.1 / 1.4.10
| Gleichrangiges in Tabs, optional/nachgeordnet in Accordions; Gliederung bleibt auch bei Reflow klar.
|===

[[sekundaere-fenstertypen]]
=== Sekundäre Fenstertypen

Sekundäre Fenstertypen ergänzen die in Kapitel <<primaere-fenstertypen>> beschriebenen Seitentypen um temporäre, kontextsensitive Anzeigekontexte.
Sie werden als Overlays oder Dialoge außerhalb bzw. innerhalb des regulären Seitenflusses dargestellt und dienen insbesondere der Fokussierung, Bestätigung oder Ergänzung von Arbeitsvorgängen.

Für sekundäre Fenstertypen gelten die gleichen Grundlagen zu <<barrierefreiheit>>, Struktur und technischer Umsetzung wie in Kapitel <<primaere-fenstertypen>> beschrieben.
Zusätzlich ist ein modalarmes Interaktionsverhalten sicherzustellen.

[[container-overlays]]
==== Container und Overlays

Container- und Overlay-Komponenten stellen eigenständige Anzeigekontexte dar, in denen Inhalte gezielt außerhalb oder innerhalb des regulären Seitenflusses dargestellt werden.

Kontextsensitive, nicht blockierende Muster (z. B. Drawer/Sidebars, Popover, Inline-Leisten) sind grundsätzlich gegenüber stark modalen Mustern zu bevorzugen.
Modale Dialoge kommen nur dann zum Einsatz, wenn sie fachlich zwingend erforderlich sind (vgl. <<modalarme-interaktionen>>).
Sekundäre Fenstertypen sind so auszugestalten, dass sie den Arbeitsfluss so wenig wie möglich unterbrechen.

Weitere Unterkapitel konkretisieren Aufbau, Inhalte und Interaktionsverhalten der einzelnen Overlay- und Dialog-Typen.

*_Barrierefreiheits-Baseline (Overlays)_*

(Detailanforderungen siehe Kapitel <<barrierefreiheit>>.)

[[r-overlays-tastatur]]
* *Tastaturbedienbarkeit:* Overlays sind vollständig per Tastatur bedienbar.
  Ein sichtbarer Fokus ist vorhanden; die Fokusreihenfolge entspricht der visuellen Struktur.

[[r-overlays-fokus]]
* *Fokusführung:* Beim Öffnen ist ein sinnvoller initialer Fokus zu setzen.
  Bei modalen Overlays ist eine Fokusfalle umzusetzen.
  Beim Schließen kehrt der Fokus an das auslösende Element zurück.

[[r-overlays-name-rolle-wert]]
* *Name/Rolle/Wert:* Relevante Informationen sind programmatisch ermittelbar (z. B. `aria-labelledby`, `aria-describedby`, bei Modalen zusätzlich `aria-modal="true"`).

[[r-overlays-reflow]]
* *Reflow/Responsivität:* Overlays sind im Rahmen der Reflow-Anforderungen ohne horizontales Scrollen nutzbar.
  Layoutsprünge bei Zustandsänderungen sind zu vermeiden.

[[container-overlays-matrix]]
*Entscheidungsmatrix*

Die folgende Entscheidungsmatrix legt fest, welche Container- und Overlay-Typen für typische Interaktionsfälle einzusetzen sind.
Sie stellt sicher, dass vergleichbare Situationen konsistent gelöst werden, die kognitive Last gering bleibt und grundlegende Anforderungen an Barrierefreiheit und User Experience eingehalten werden.

[cols="3,3,4,2", options="header"]
|===
| Interaktionsfall | Empfohlener Container | Begründung | PrimeNG (Bezug)

| Kurze, reversible Bestätigung
| Popover nahe Auslöser
| Entscheidung im Kontext; minimaler Fokuswechsel; optionales Undo per Toast
| `p-popover`, `p-toast`

| Kontextnahe Bearbeitung (ein Formularabschnitt)
| Drawer/Side Panel (nicht blockierend)
| Arbeitskontext bleibt sichtbar; geringere kognitive Last als Modal
| `p-sidebar` (Drawer)

| Mehrschritt-Anlage / komplexer Flow
| Seiteneigener Stepper (nicht modal)
| Bessere Orientierung, History/Deeplinks möglich; Inline-Validierung
| `p-stepper`, `p-message`

| Rechtlich/irreversibel/hochriskant
| Modaler Dialog (nur wenn zwingend)
| Explizite Willensbekundung erforderlich; Input-Fokus abgesichert
| `p-dialog [modal]="true"`

| Systemhinweis/Status
| Toast/Snackbar (global) / Inline-Message
| Nicht blockierend; Screenreader-kompatibles Live-Region-Verhalten
| `p-toast`, `p-message`

| Hilfe/Kontextinfo
| Popover oder Expander (inline)
| Zusatzinfos ohne Unterbrechung des Workflows
| `p-popover`, Accordion/Expander
|===

Die nachfolgenden Abschnitte konkretisieren den in dieser Entscheidungsmatrix aufgeführten Dialog als Overlay-Typ und legen Aufbau, Einsatz und spezielle Varianten (z. B. Meldungsdialoge für Bestätigungen und Warnungen) verbindlich fest.

[[dialoge]]
==== Dialoge

Dialoge sind ein in <<container-overlays>> definierter Overlay-Typ.
Sie sind sekundäre Fenster über dem Hauptinhalt, die bei modaler Verwendung den Seitenkontext blockieren.
Sie werden primär eingesetzt für kurze, fokussierte Aufgaben, rechtlich notwendige Bestätigungen sowie kompakte Dateneingaben, die nicht sinnvoll inline oder im Drawer lösbar sind.

*_Aufbau_*

* *Titelzeile (A):* Die Titelzeile ist aussagekräftig und benennt Aktion und Zielobjekt (z. B. „Personalie XY löschen“).
  Ein optionaler Subtitel kann die Situation präzisieren (z. B. „Personalie hinzufügen – Registerdatensatz XY“; Haupttitel „Personalie hinzufügen“, Subtitel „Registerdatensatz XY“).
  Eine Farbmarkierung im Rahmen der Applikation ist zulässig.

* *Inhaltsbereich (B):* Der Inhaltsbereich bleibt kompakt und beschränkt sich auf die konkrete Eingabe bzw. Information.
  Optional kann ein oberer Hinweis-/Validierungsbereich (Statusmeldung) verwendet werden.

* *Buttonleiste \(C):* Die Buttonleiste enthält Primäraktion (z. B. Löschen, Speichern), Sekundäraktion(en) und Abbrechen.
  Reihenfolge und Benennung sind in der gesamten Anwendung einheitlich.

{empty} +

[[image-aufbau-abc]]
.Aufbau Dialog
image::Dialog_Aufbau_ABC.png[align="center", width="627",height="249"]

{empty} +

*_Richtlinien zur Anwendung_*

[[r-dialoge-modalitaet]]
* *Modalität:* Modalität wird nur bei fachlicher Erforderlichkeit eingesetzt.
  Inline-Muster oder Confirm-Popups sind vorzuziehen.

* *Stapelung:* Dialog-Kaskaden sind zu vermeiden. 
  Eine zweite Ebene ist nur in Ausnahmefällen zulässig. 
  Schließreihenfolge entspricht Öffnungsreihenfolge.

* *Größe:* Die Dialoggröße richtet sich nach dem Inhalt.
  Maximalmaße orientieren sich an Viewport bzw. Hauptfenster.
  Der Dialog darf intern scrollen; der Hintergrund bleibt bei Modalität gesperrt.
  Horizontales Scrollen ist zu vermeiden.

* *Konsistentes Raster:* Formulare im Dialog folgen demselben Feldlayout wie im Read-Modus (in der Regel dreispaltiges Raster; in schmalen Viewports 2→1, vgl. <<layout-resizing>>).

*Dialog-Typen*

[cols="1,3,2", options="header"]
|===
| Dialog-Typ
| Beschreibung / empfohlener Einsatz
| PrimeNG (Bezug)

| Modal
| Blockiert den Hintergrund. Nur für rechtlich erforderliche, irreversible, sicherheitskritische oder transaktionale Commit-Aktionen.
| `p-dialog [modal]="true"`

| Modeless
| Blockiert den Hintergrund nicht, überlagert nur den Inhalt. Für ergänzende, kurze Aufgaben (z. B. Details bearbeiten).
| `p-dialog [modal]="false"`

| Sheet (Bottom/Side Sheet)
| Am Rand angedockt, weniger intrusiv. Für mobile bzw. kompakte Bestätigungen oder sekundäre Panels.
| `p-dialog [modal]="true" position="bottom"` oder `p-sidebar position="right/left"`

| Vollbild
| Nutzt den gesamten Viewport. Nur bei sehr komplexen, zeitlich fokussierten Aufgaben mit klarer Rückkehr in den Ausgangskontext.
| `p-dialog [modal]="true" [style]="{width:'100vw', height:'100vh'}` +
oder eigene Page-Route (bevorzugt)
|===

[[meldungsdialoge]]
==== Meldungsdialoge

Meldungsdialoge sind eine spezialisierte Form von Dialogen.
Sie sind blockierende Overlays, die den Hintergrund sperren und eine sofortige, bewusste Entscheidung erfordern.
Sie dienen der Absicherung kritischer Aktionen oder der Unterbindung riskanter Zustände.

*_Zwingende Einsatzfälle für Meldungsdialoge_*

[[r-meldungsdialoge-einsatzfaelle]]
* Irreversible, rechtlich wirksame oder sicherheitskritische Aktionen, z. B. Objekt löschen, Veröffentlichung freigeben, rechtlich bindend absenden.

* Drohender Datenverlust, z. B. „Ungespeicherte Änderungen verwerfen?“.

* Nicht fortsetzbarer Fehlerzustand, z. B. Sitzung abgelaufen, Authentifizierung fehlgeschlagen und erneute Eingabe erforderlich.

* Nicht einsetzen für reine Informationen oder reversible Aktionen.
  Dafür sind modalarme Alternativen zu verwenden (vgl. <<bestaetigen-rueckgaengig>>).

{empty} +

[[image-meldungsdialogobjloeschen]]
.Meldungsdialog – Objekt löschen
image::Dialog_Meldung_ObjektLoeschen.png[align="center", width="329",height="163"]


[[image-aufbaumeldungsdialog]]
.Aufbau Meldungsdialog
image::Aufbau_Meldungsdialog.png[align="center", width="325",height="162"]

{empty} +

*_Aufbau_*  

* *Titelzeile (A):* Die Titelzeile muss Aktion und Zielobjekt eindeutig formulieren, z. B. „Vorgang 4711 löschen“.

* *Meldungs-Icon (B):* (optional, abhängig von der Severity) unterstützt die Einordnung der Meldung (Info/Warnung/Fehler); Farbe wird dabei nicht als einziges Unterscheidungsmerkmal verwendet.

* *Beschreibung (C):* Die Beschreibung ist als kurzer Satz zur Wirkung bzw. Folge zu formulieren;
  technische Pfade oder IDs sind nicht im Fließtext zu verwenden.
  Zusätzliche Details (z. B. Fehlercodes, Support-Hinweise) sind bei Bedarf in einem Expander bereitzustellen (Progressive Disclosure).

* *Dialogbuttons (D):* Dialogbuttons sind eindeutig und aktionsbezogen zu beschriften (statt „OK/Ja/Nein“).
  Es sind mindestens eine Primäraktion (z. B. „Löschen“) und „Abbrechen“ anzubieten.
  Redundante Kombinationen wie „Nein“ + „Abbrechen“ sind zu vermeiden.

==== Normative Bezüge

[cols="3,2,3", options="header"]
|===
| Anforderung | Normbezug | Akzeptanzkriterium

| <<r-overlays-tastatur,Tastaturbedienbarkeit Overlays>>
| WCAG 2.1.1 / 2.1.2 / 2.4.7
| Overlays vollständig per Tastatur bedienbar; sichtbarer Fokus; keine Tastaturfalle.

| <<r-overlays-fokus,Fokusführung Overlays>>
| WCAG 2.4.3 / 2.4.7
| Beim Öffnen sinnvoller Initialfokus; Fokusreihenfolge folgt der visuellen Struktur.

| <<r-overlays-name-rolle-wert,Overlays programmatisch erkennbar (Name/Rolle/Wert)>>
| WCAG 4.1.2
| Overlays und Controls mit programmatisch ermittelbarem Name/Rolle/Zustand; modale Overlays nutzen `aria-modal`.

| <<r-overlays-reflow,Overlays: Reflow & Responsivität>>
| WCAG 1.4.10
| Bis 400 %/320 px ohne horizontales Scrollen nutzbar; Inhalte/Funktionen bleiben erhalten.

| <<r-dialoge-modalitaet,Dialoge: Modalität nur bei Erforderlichkeit>>
| WCAG 3.3.4
| Stark modale Dialoge nur bei rechtlich/finanziell/datenkritischen Aktionen; unterstützen Prüfen/Bestätigen.

| <<r-meldungsdialoge-einsatzfaelle,Meldungsdialoge: zwingende Einsatzfälle>>
| WCAG 3.3.4
| Meldungsdialoge sperren Hintergrund nur bei irreversiblen, sicherheitskritischen Aktionen oder drohendem Datenverlust; sonst modalarme Muster.
|===

[[interaktionsmuster]]
=== Interaktionsmuster

Interaktionsmuster definieren wiederkehrende Abläufe und Rückmeldungen für häufige Use-Cases (z. B. Bestätigen & Rückgängig, Benachrichtigungen, Assistent/Stepper).
Ziel ist eine modalarme, effiziente und konsistente Bedienung: bevorzugt Inline-, Drawer- oder Popover-Lösungen statt blockierender Dialoge, klare Aktionslabels, Undo-Optionen sowie feldnahe Validierung mit ergänzender Statusmeldung.

Die Muster sind tastatur- und screenreader-tauglich gemäß Kapitel <<barrierefreiheit>> und greifen auf Angular + PrimeNG/PrimeFlex zurück (Komponenten dienen als Referenz).
Entscheidungskriterien und Barrierefreiheitsgrundlagen siehe <<container-overlays>>.

[[bestaetigen-rueckgaengig]]
==== Bestätigen & Rückgängig

Bestätigungen und Rücknahmen erfolgen im Kontext, ohne Arbeitsfluss oder Lesereihenfolge unnötig zu unterbrechen.
Wo immer fachlich vertretbar, wird eine Rückgängig-Option (Undo) angeboten.

*_Aufbau_*

* *Inline-Bestätigungsleiste:* Kurzer Hinweistext unmittelbar am betroffenen Bereich; Primär- und Alternativaktion sind klar benannt.

* *Angedockte Bestätigung am Auslöser:* Kompakter Popover/ConfirmPopup neben dem auslösenden Element.

* *Undo-Rückmeldung:* Unmittelbar nach schneller, reversibler Aktion (z. B. „Archiviert — Rückgängig“).

*_Richtlinien zur Anwendung_*

* *Kontextnah statt modal:* Bestätigungen erfolgen bevorzugt inline oder am Auslöser; modale Dialoge nur bei rechtlicher Relevanz, Irreversibilität oder Sicherheitsbezug.

* *Eindeutige Sprache:* Aktionslabels beschreiben die Konsequenz („Löschen“, „Archivieren“), keine Ja/Nein-Rätsel.

[[r-bestaetigen-undo]]
* *Rücknahme ermöglichen:* Reversible Aktionen bieten einen Undo in angemessener Zeitspanne (in der Regel 5–10 s).

* *Barrierefreiheit & Fokus:* Bestätigungen übernehmen den Fokus nicht dauerhaft.
  Beim Schließen kehrt der Fokus zum Auslöser zurück.
  Statusmeldungen sind über eine Live-Region für Screenreader erkennbar, ohne Fokus-Sprung.

*_Verhalten_*

* *Tastatur:* *Enter* aktiviert die Primäraktion, *Esc* bricht die Bestätigung ab.

* *Screenreader:* Kurztexte benennen Aktion und Objekt; Undo wird als interaktives Element angekündigt.

* *Mobil:* Zielgrößen sind ausreichend dimensioniert; Popover werden so positioniert, dass keine kritischen Bereiche verdeckt werden.

*_PrimeNG-Mapping (Referenz)_*

* *Inline-Leiste:* Message-Komponente oder eigener Inline-Container + `p-button`.

* *Angedockt:* `p-popover` oder `p-confirmPopup` mit klaren Aktionen.

* *Undo:* `p-toast` (+ `MessageService`) mit Aktion (Button/Link).

[[inline-edit_inline_validation]]
==== Inline-Edit & Inline-Validation

Fachliche Änderungen erfolgen im Sichtkontext (Abschnitt, Karte, Tabellenzeile), ohne modale Blockade und ohne Seitenwechsel.
Die Validierung erklärt feldnah die Ursache und bietet zusätzlich eine knappe globale Zusammenfassung.

*_Aufbau_*

* Inline-Edit-Bereiche in Detailabschnitten oder Tabellen (Zeilen-/Zellen-Edit).

* Feldnahe Hilfen/Fehler mit eindeutiger Zuordnung (`aria-describedby`), inkl. konkretem Hinweis zur Behebung.

* Globale Statuszone im Abschnitt oder Seitenkopf (z. B. „3 Felder prüfen“).

*_Richtlinien zur Anwendung_*

* *Start des Editierens:* Der Fokus springt auf das erste relevante Feld; der Edit-Kontext ist visuell erkennbar.

* *Speichern/Abbrechen:* Aktionen gelten lokal für den aktuellen Bereich (Abschnitt/Zeile).

[[r-inlineedit-validierung]]
* *Validierung & Barrierefreiheit:* Validierung erfolgt sofort (on blur) oder beim Speichern.
  Die Primäraktion ist nur bei Gültigkeit aktiv – alternativ springt der Fokus zum ersten fehlerhaften Feld.
  Fehlerzustände setzen `aria-invalid="true"`; der erklärende Text ist über `aria-describedby` programmatisch verbunden.

*_Verhalten_*

* *Tastatur:* *Enter* speichert (bei gültigen Daten), *Esc* verwirft lokal.
  Die Tab-Reihenfolge entspricht dem Lesefluss.

* *Rückmeldung:* Erfolg wird als nicht blockierende Meldung (z. B. Toast oder Inline-Hinweis) kommuniziert.
  Fehler bleiben sichtbar, bis sie behoben sind.

* *Strukturierung:* Große Bereiche werden mit Tabs/Accordion gegliedert; jedes Panel bleibt unabhängig validierbar.

*_PrimeNG-Mapping (Referenz)_*

* Formulare mit Angular `FormGroup` + PrimeNG Inputs (`p-inputText`, `p-dropdown` usw.).

* Tabellen-Edit mit `p-table` (Row/Cell Editing) inkl. Save/Cancel.

* Fehlermeldungen über `p-message` (inline) + optional `p-toast` (global).

[[benachrichtigungen]]
==== Benachrichtigungen

System- und Fachereignisse werden wahrnehmbar, aber nicht blockierend kommuniziert.
Meldungen unterstützen Verständnis und nächste Schritte, ohne den Fokus zu entziehen.

*_Aufbau_*

* Globale Benachrichtigungen (Toast/Snackbar) für asynchrone Ereignisse: Erfolg, Hinweis, Warnung, Fehler.

* Inline-Hinweise im betroffenen Abschnitt/Feld.

* Kombinierte Darstellung: feldnahe Fehler + globale Zusammenfassung.

*_Richtlinien zur Anwendung_*

* *Schließen/Timeout:* Info-Toasts dürfen automatisch ausblenden; Warnungen/Fehler benötigen in der Regel ein explizites Schließen.

[[r-benachrichtigungen-status]]
* *Kein Fokus-Hijack:* Meldungen nutzen `aria-live` (in der Regel `polite`); der Fokus bleibt beim Nutzer.

* *Text statt Farbe:* Schweregrade werden sprachlich benannt; Farbe wirkt unterstützend.

* *Anzahl gleichzeitiger Meldungen:* Mehrere Meldungen überlagern keine Primäraktionen; ältere Meldungen werden geordnet abgebaut.

*_Verhalten_*

* *Screenreader:* Meldungstexte sind kurz, klar und ohne redundante Details; optional kann „Details anzeigen“ angeboten werden.

* *Mobil:* Platzierung so wählen, dass wichtige Interaktionen nicht verdeckt werden.

*_PrimeNG-Mapping (Referenz)_*

* Globale Meldungen über `p-toast` (+ `MessageService`).

* Inline-Hinweise über `p-message` im jeweiligen Kontext.

[[stepper]]
==== Stepper

Ein Stepper bildet eine geführte Abfolge von Interaktionsschritten ab.
Er eignet sich für Fälle, in denen Nutzende schrittweise durch eine komplexe Aufgabe geführt werden sollen (z. B. mehrstufige Objektanlage oder -konfiguration).
Durch die Aufteilung in klar benannte Schritte sinkt die wahrgenommene Komplexität.

Der Stepper wird seitenintern im Inhaltsbereich oder in einem Drawer eingesetzt.
Blockierende Modaldialoge sind zu vermeiden und nur in begründeten Ausnahmefällen zulässig (z. B. rechtlich erforderliche Bestätigung).
Technologie-Referenz ist der PrimeNG Stepper (v20+) bzw. eine gleichwertige Umsetzung; das Layout erfolgt mit PrimeFlex/CSS-Grid.

[[image-stepper1]]
.Beispiel eines Dialog Wizards
image::Stepper_Beispiel.png[align="center", scaledwidth="96%"]

[[image-stepper2]]
.Aufbau eines Dialog Wizards
image::Stepper_Aufbau.png[align="center", scaledwidth="96%"]

*_Aufbau_*

* *Titelzeile (A):* Beschreibt die Aufgabe verständlich (z. B. „Neuen Antrag anlegen“) und verortet sie fachlich.
  Regeln für Titelzeilen entsprechen denen von Dialogen.

* *Schrittanzeige (B):* Lineare Abfolge von Schritten (horizontal oder vertikal).
  Der aktuelle Schritt ist visuell hervorgehoben; erledigte Schritte sind erkennbar (z. B. Haken).
  Optional wird der Fortschritt (n/gesamt) angezeigt.

* *Inhaltsbereich \(C):* Formulare und Komponenten des aktiven Schritts.
  Leer-, Lade- und Fehlerzustände sind definiert.
  Das Layout folgt dem allgemeinen Raster (Reflow 3→2→1, kein horizontales Scrollen).

* *Steuerleiste (D):* Primäraktionen: **Weiter** / **Abschließen** (im letzten Schritt), **Zurück**.
  Sekundäraktionen: **Abbrechen**, **Zwischenspeichern/Ablegen** (falls fachlich sinnvoll).
  Position, Beschriftung und Tastaturverhalten sind konsistent.

*_Richtlinien zur Anwendung_*

* *Linearität & Navigation:*
** Standard ist ein linearer Stepper: „Weiter“ erst nach valider Eingabe.
** „Zurück“ ist jederzeit möglich; erledigte Schritte dürfen direkt angewählt werden.
** Vorwärtsnavigation per Schrittanzeige ist nur zulässig, wenn Folgeschritte inhaltlich unabhängig sind.

[[r-stepper-validierung]]
* *Validierung & Feedback:*
** Validierung erfolgt feldnah (inline) mit verständlichen Fehltexten, ergänzt um eine globale Meldungszone (`role`/`aria-live`) pro Schritt.
** Weiter/Abschließen bleibt deaktiviert, bis Pflichtfelder valide sind.
** Bei „Weiter“ springt der Fokus zur Fehlersumme oder zum ersten fehlerhaften Feld (programmatisch fokussierbar, z. B. `tabindex="-1"` + Fokus).
** Modale Fehlermeldungen werden vermieden.

[[r-stepper-navigation]]
* *Fokusführung & Tastatur:*
** Beim Schrittwechsel wird der Fokus auf die Schritt-Überschrift oder den ersten sinnvollen Inhalt gesetzt.
** Die Tab-Reihenfolge folgt der Sichtreihenfolge; *Enter* löst die Primäraktion aus, *Esc* bricht ab (sofern kein Datenverlust droht, sonst Bestätigung im Kontext).
** Die Schrittanzeige ist tastaturbedienbar (Links/Buttons mit sichtbarem Fokus; semantisch als `tablist`/`region` o. Ä., abhängig von der Komponenten-API).

[[r-stepper-reflow]]
* *Zustände & Reflow:*
** Skeleton ab ca. 300 ms; Fehlerzustände mit hilfreichem Text und Retry.
** Keine Layoutsprünge beim Wechsel der Zustände; keine horizontale Scrollbar im Fließtext.
** Mobil: vertikale Anordnung; die Steuerleiste bleibt erreichbar und verschwindet nicht dauerhaft unterhalb des Viewports.

* *Zwischenspeichern & Abbruch:*
** Zwischenspeichern/Ablegen ermöglicht Unterbrechung und spätere Fortsetzung (z. B. Wiedervorlage im Dashboard).
** Abbrechen verwirft Änderungen nur nach klarer, nicht-modaler Bestätigung im Kontext (Bestätigungsleiste/Popover) mit optionalem Undo.

* *Anti-Pattern (vermeiden):*
** Stepper im modalen Dialog ohne zwingenden Grund.
** Komplexe Branching-Szenarien mit stark divergierenden Pfaden (besser: Vorab-Entscheid, dann schlanke Linie).
** Uneinheitliche Primäraktionen („OK“ statt „Weiter/Abschließen“).
** Fehler ausschließlich als Toast ohne feldnahe Erklärung.
** Verlust des Formularzustands beim Navigieren (Zurück/Weiter).

==== Normative Bezüge

[cols="3,2,3", options="header"]
|===
| Anforderung | Normbezug | Akzeptanzkriterium

| <<r-bestaetigen-undo,Bestätigen & Rückgängig: Undo-Option>>
| WCAG 3.3.4 / 4.1.3
| Reversible Aktionen mit zeitlich begrenzter Undo-Option; Status-/Undo-Meldungen programmatisch als Status erkennbar (z. B. `aria-live`).

| <<r-inlineedit-validierung,Inline-Edit: Validierung & Fehlerbeschreibung>>
| WCAG 3.3.1 / 3.3.3 / 4.1.3
| Fehler feldnah textlich beschrieben, ggf. zusammengefasst; konkrete Korrekturhinweise; Zuordnung z. B. via `aria-describedby`.

| <<r-benachrichtigungen-status,Benachrichtigungen: Statusmeldungen ohne Fokus-Hijack>>
| WCAG 4.1.3
| Benachrichtigungen per `aria-live` angekündigt, ohne Fokuswechsel; Schweregrad und nächste Schritte sprachlich beschrieben.

| <<r-stepper-validierung,Stepper: Validierung und Fehlerbehandlung>>
| WCAG 3.3.1 / 3.3.3
| Ungültige Pflichtfelder verhindern Fortfahren; Fehler textlich gekennzeichnet und ggf. zusammengefasst.

| <<r-stepper-navigation,Stepper: Fokusführung & Tastaturbedienung>>
| WCAG 2.1.1 / 2.4.3 / 2.4.7
| Stepper vollständig tastaturbedienbar; Fokus springt beim Schrittwechsel nachvollziehbar zur Überschrift oder zum ersten Inhalt.

| <<r-stepper-reflow,Stepper: Zustände & Reflow>>
| WCAG 1.4.10
| Stepper reflowt 3→2→1 ohne horizontales Scrollen; Leer/Lade/Fehlerzustände verursachen keine störenden Layoutsprünge.
|===

[[navigation]]
=== Navigation

Alle Use Cases einer Fachanwendung müssen, gegebenenfalls nach Anwendungskomponenten oder Anwendungen gruppiert, direkt über einen Eintrag in der Navigation ansprechbar sein.

[[image_beispiel_navigation]]
.Beispielnavigation
image::24_DP_beispiel_navigation.png[align="center"]

Die IsyFact sieht drei Navigationsebenen vor:

* Die Hauptnavigation (auch horizontale Navigation genannt)
* Die darin enthaltene Subnavigation (Menüitems der Hauptnavigation)
* Die Linksnavigation (Liste von Einträgen am linken Rand der Applikation)

Innerhalb einer Anwendungslandschaft oder einer einzelnen Fachanwendung muss die Navigation einheitlich strukturiert sein.

Je nach Komplexität der Anwendung oder Anwendungslandschaft gibt es verschiedene Möglichkeiten eine Navigation zu gestalten.
Alle Navigationen haben gemeinsam, dass sie ihren Use Case auf letzter Ebene in der Linksnavigation haben.
Die Subnavigation kann dabei die übergeordnete Anwendungskomponente oder Anwendung enthalten.
Die Hauptnavigation bildet entsprechend der Subnavigation die Anwendung (oder eine logische Gruppe der Anwendungskomponenten) oder sogar eine Anwendungsgruppe ab.

Dies sieht in einfachen Fällen wie folgt aus:

* Anwendung (Hauptnavigation) enthält
* Anwendungskomponente (Subnavigation) enthält
* Use Case (Linksnavigation)

In komplexeren übergreifenden Szenarien kann eine Navigation wie folgt aussehen:

* Anwendungsgruppen (Hauptnavigation) enthält
* Anwendungen (Subnavigation) enthält
* Use Case (Linksnavigation, nach Möglichkeit gruppiert)

[NOTE]
Dies sind nur exemplarische Möglichkeiten eine Hierarchie innerhalb der zur Verfügung stehenden Elemente aufzubauen.

[[hauptnavigation]]
==== Hauptnavigation

Die Hauptnavigation ist eine horizontale Navigation, die stets am unteren Rand des Header-Bereichs dargestellt wird.
Sie wird mit Menüpunkten von links nach rechts befüllt.
Im optimalen Fall sind die Menüpunkte ihrer Priorität nach angeordnet.
Im optimalen Fall hat die Hauptnavigation nicht mehr als 4-7 Menüpunkte.
Die Hauptnavigation ist nicht scrollbar und enthält kein TabOverflow.

[[image-hauptnavigation]]
.Hauptnavigation
image::24_DP_hauptnavigation.png[align="center"]

Unterhalb der Hauptnavigation wird ein Farbbalken angezeigt.
Die Farbe repräsentiert eine Anwendung oder eine Anwendungsgruppe und kann entsprechend ihrer aktiven Auswahl die Farbe ändern.
Die Subnavigation öffnet sich per Mausklick.

[[subnavigation]]
==== Subnavigation

Die Subnavigation ist eine vertikale Navigation, die immer an einem Menüpunkt der Hauptnavigation beginnt.
Sie wird mit Menüpunkten von oben nach unten befüllt.
Im optimalen Fall sind die Menüpunkte ihrer Priorität nach angeordnet.
Nach Möglichkeit sind die Menüpunkte logisch gruppiert.
Die Subnavigation ist nicht scrollbar.

[[image-subnavigation]]
.Subnavigation
image::24_DP_subnavigation.png[align="center"]

Die Subnavigation wird zum Öffnen von Anwendungskomponenten oder Anwendungen, deren Navigation sich in der Linksnavigation fortsetzt, genutzt.

[[linksnavigation]]
==== Linksnavigation

Die Linksnavigation ist eine vertikale Navigation am linken Bildschirmrand.
Sie lässt sich ein und ausblenden.
Die Linksnavigation wird mit Menüpunkten von oben nach unten befüllt.
Im optimalen Fall sind die Menüpunkte ihrer Priorität nach angeordnet.
Nach Möglichkeit sind die Menüpunkte logisch gruppiert.

[[image-linksnavigation]]
.Linksnavigation geschlossen (gruppiert)
image::24_DP_linksnavigation_closed.png[align="center"]

Per Mausklick lassen sich in der Linksnavigation die Gruppierungen öffnen.

[[image-linknavigation-offen]]
.Linksnavigation geöffnet (gruppiert)
image::24_DP_linksnavigation_open.png[align="center"]

Diese bleiben auch beim weiteren Öffnen von anderen Gruppen weiterhin offen und verhalten sich an dieser Stelle wie ein <<panel>>.
Die Linksnavigation enthält optional übergeordnet den Anwendungs- oder Anwendungskomponentennamen.
Über die Linksnavigation ist kein Anwendungswechsel möglich.

[TIP]
Müssen Anwendende häufig auf bestimmte Funktionen oder Objekte zugreifen, so kann es sinnvoll sein, Schnellzugriffe einzurichten.
Diese können statisch implementiert sein (zum Beispiel über "häufige Aufgaben") oder sich dynamisch ändern, je nach Nutzung (zum Beispiel über "häufig benutzt").

[[toolbar]]
=== Toolbar

Eine Toolbar stellt ein Set von <<bedienelemente,Bedienelementen>>, wie zum Beispiel <<button,Buttons>> oder <<dropdown,Dropdown-Menüs>>, in einer Leiste zur Verfügung.
Diese ist oberhalb eines bestimmten Inhaltsbereichs angebracht und sollte optisch, beispielsweise durch eine vertikale Trennlinie, von diesem abgegrenzt sein.
Die einzelnen Funktionen innerhalb der Toolbar werden typischerweise durch ein aussagekräftiges <<icons,Icon>>, gegebenenfalls ergänzt um ein zusätzliches <<label>>, repräsentiert.

Die Toolbar soll das Gefühl einer schnellen und simplen Interaktion vermitteln.
Daher sollten keine komplexen Funktionalitäten in der Toolbar untergebracht werden.
Gängige Funktionen wie Drucken oder Löschen sind typische Beispiele für eine Toolbar.
Im Vergleich zu einem Menü sind die Funktionen in einer Toolbar immer sichtbar und direkt erreichbar.

Folgende Toolbars gibt es:

* Seiten-Toolbar
* Tabellen-Toolbar
* Eingabefeldgruppen mit Toolbar

*_Dos:_*

* In einer Toolbar finden sich die wichtigsten oder am häufigsten genutzten Funktionen an einem zentralen Platz.
* Bedienelemente in einer Toolbar sollten entsprechend ihrer Verfügbarkeit aktiviert oder deaktiviert werden.
* Nicht aussagekräftige Icons sollten mit einem Label versehen werden.
* Die Anordnung der Elemente innerhalb einer Toolbar sollte nach deren Priorität beziehungsweise nach deren Nutzungsfrequenz erfolgen – häufig genutzte Funktionen links, weniger häufig genutzte Funktionen rechts.
* Zusammengehörige Funktionen können aus Platzgründen in <<menu-button,Menü-Buttons>> zusammengefasst werden.
* Wird die Größe des Browserfensters verändert, so wächst die Toolbar in die Breite mit.
Die Elemente in der Toolbar behalten ihre ursprüngliche Größe und Position bei.

*_Don'ts:_*

* Eine Toolbar sollte nicht mit allen zur Verfügung stehenden Bedienelementen überladen werden.
Stattdessen sollten die am häufigsten benötigten oder sehr wichtige Funktionen repräsentiert werden.
* Es sollten keine mehrzeiligen Toolbars eingesetzt werden.

*_Seiten-Toolbar_* *WiP*

//Die Seiten-Toolbar kann als Bestandteil der Frontendstruktur unterhalb der <<hauptnavigation>> eingebaut werden (wie beispielhaft in <<image_beispiel_navigation>> zu sehen).
//Sie beinhaltet Funktionen, welche für das gesamte Frontend gelten, zum Beispiel „Zurück zur Übersicht“, „Seite drucken“ oder „Hilfe“.

//[[image-seitentoolbar]]
//.Seiten-Toolbar
//image::ToDo[align="center"]

//Auf der linken Seite befindet sich in jeder Seiten-Toolbar eine <<link,Verlinkung>>, die zurück zur dazugehörigen Hauptseite führt.
//Der Navigationslink wird mit einer Kombination aus Icon und Label implementiert.
//Alle anderen Funktionen sind als Icon-Buttons einzubauen.

*_Tabellen-Toolbar_* *WiP*

//[[image-tabellentoolbar]]
//.Tabellen-Toolbar
//image::ToDo[align="center"]

*_Eingabefeldgruppen mit Toolbar_* *WiP*

//[[image-eingabefeldgruppe-mit-toolbar]]
//.Eingabefeldgruppen mit Toolbar
//image::ToDo[align="center"]

[[expander]]
=== Expander (Progressive Disclosure)

Mit einem Expander können bestimmte Inhaltsbereiche per Mausklick dynamisch ein- und ausgeblendet werden.
Das zugrundeliegende Prinzip wird häufig als „Progressive Disclosure“ („schrittweises Enthüllen“) oder auch als „Information Hiding“ („Ausblenden von Information“) bezeichnet.

Ein Expander wird genutzt, um die Informationskomplexität zu reduzieren und um vertikal Platz einzusparen (beispielsweise bei langen <<formulare,Formularen>>).
Hierfür werden die Inhalte in logische Gruppen zusammengefasst, die sich zur besseren Übersicht ein- und ausklappen lassen.
In einem Expander können sowohl <<basiselemente,Basis>>- und <<bedienelemente>> als auch <<design-pattern,Design Patterns>> angezeigt werden.

Der grundlegende Aufbau eines Expanders ist wie folgt:

* Einen Header-Bereich mit
** einem gruppierenden <<label>>, das den Inhalt der Gruppe prägnant beschreibt,
** und einem <<icons,Icon>>, das den Zustand des Expanders anzeigt.
* Einen Content-Bereich, der die Inhalte der Gruppe enthält.

Expander nehmen dabei immer die ihnen zur Verfügung stehende Breite ein.

[NOTE]
Anstatt mehrere Expander in einer Ansicht zu nutzen, sollte überlegt werden, ob die fachlich gesplitteten Gruppierungen besser in <<tabview,Tabs>> oder sogar in eigenen Frontendseiten dargestellt werden sollten.
Dadurch wird die kognitive Belastung der Nutzenden reduziert und das Fehlerhandling vereinfacht.
Des Weiteren ist es barrierefreier, wenn weniger Inhalt auf einem Frontend direkt sichtbar ist.
Screenreader können dadurch schneller und einfacher durch die Inhalte navigieren.

[[akkordeon]]
==== Akkordeon

In einem Akkordeon werden zu einem übergeordneten Thema strukturiert und gegliedert Inhalte dargestellt.
Dabei lässt sich nur ein Akkordeonelement gleichzeitig ausklappen.
Alle anderen Akkordeonelemente sind oder werden eingeklappt.
So wird der Fokus auf genau dieses Inhaltsfragment gelegt.
Eine klassische Anwendung hat das Akkordeon beispielsweise in FAQs.

[[image-akkordeon-eingeklappt]]
.Akkordeon ohne ausgeklapptes Element
image::24_DP_akkordeon_eingeklappt.png[align="center"]

[[image-akkordeon-ausgeklappt]]
.Akkordeon mit ausgeklapptem Element
image::24_DP_akkordeon_ausgeklappt.png[align="center"]

Fürs Aus- und Einklappen eines Akkordeonelements kann der gesamte Akkordeon-Header angeklickt werden.
Zusätzlich befindet sich auf der linken Seite neben dem Label ein Icon, das den Zustand (ein- oder ausgeklappt) des Akkordeonelements anzeigt.
Als Icon wird ein Chevron genutzt, das entweder nach rechts zeigt, wenn das Element eingeklappt ist, oder nach unten, wenn das Element ausgeklappt (siehe Abbildungen <<image-akkordeon-ausgeklappt>> und <<image-akkordeon-eingeklappt>>).

Die Interaktion wird dabei in der Regel auf die reine Wissensvermittlung reduziert.
Entsprechend soll auf weiterführende Interaktion, über das aus- und einklappen hinaus, verzichtet werden.

[[panel]]
==== Panel

Ein Panel ist einem <<akkordeon>> recht ähnlich.
In einem Panel werden ebenso zu einem übergeordneten Thema kompakt Gruppen an Informationen dargestellt.
Dabei lässt sich das ausgewählte Panel ausklappen.
Weitere Panels innerhalb des Frontends werden durch ein Aus- oder Einklappen nicht beeinflusst.
So können Nutzende alle Informationsgruppen eigenständig anzeigen oder bei Bedarf ausblenden.
Klassischerweise werden Panels in <<formulare,Formularstrecken>> verwendet.

[[image-panel-eingeklappt]]
.Eingeklapptes Panel
image::24_DP_panel_eingeklappt.png[align="center"]

[[image-panel-ausgeklappt]]
.Ausgeklapptes Panel
image::24_DP_panel_ausgeklappt.png[align="center"]

Fürs Aus- und Einklappen eines Panels befindet sich auf der linken Seite auf der Höhe des Labels ein Icon.
Als Icon wird ein Chevron genutzt, das entweder nach rechts zeigt, wenn das Element eingeklappt ist, oder nach unten, wenn das Element ausgeklappt (siehe Abbildungen <<image-panel-ausgeklappt>> und <<image-panel-eingeklappt>>).

Die Interaktion steht hier im Vordergrund.
Weiterführende Aktionen können entweder rechts im Panel Header oder in einer Footer Sektion unterhalb des Inhaltsbereichs eingebaut werden.

Technisch sind Panels meist flexibler, beziehungsweise nicht so restriktiv, wie ein Akkordeon.
Eine Gegenüberstellung, wann ein Panel und wann ein Akkordeon sinnvoll ist, befindet sich im Kapitel <<panel-akkordeon-ueberschrift>>.

[[dropdown]]
=== Eingabefeldliste (Dropdown)

Ein Eingabefeld mit hinterlegten Werten ist in seiner einfachsten Form ein Eingabefeld mit Liste.
Die Liste ist die bekannteste Art eines interaktiven Eingabefelds, besser bekannt als Dropdown.

Eingabefeldlisten setzen Standards für interaktive <<eingabefeld,Eingabefelder>>, Dropdown-Menüs, enthaltene Kontrollkästchen und andere interaktive Elemente.
Dadurch wird sichergestellt, dass alle Eingabefelder auf dem Frontend einheitlich gestaltet sind und den besten Praktiken hinsichtlich <<usability-und-benutzerfreundlichkeit,Benutzerfreundlichkeit>> und <<barrierefreiheit>> entsprechen.
Ein konsistentes Design fördert die Orientierung und das Vertrauen der Nutzenden, was letztendlich zu einer höheren Zufriedenheit und Effizienz führt.

[[image-eingabefeldliste-dropdown]]
.Eingabefeld mit hinterlegten Auswahlmöglichkeiten
image::24_DP_eingabefeldliste.png[align="center"]

Beim Klick auf das gesamte Element klappt die Liste aus und ein Element kann angewählt werden.

[[image-eingabefeldliste-aktiv-aktives-dropdown]]
.Aktives Dropdown
image::24_DP_eingabefeldliste_aufgeklappt.png[align="center"]

Die Listenelemente sind mindestens 44px hoch und so breit wie das dazugehörige Element (hier exemplarisch das Eingabefeld).
Aktive Listenelemente sind in der Highlightfarbe und hinterlegt dargestellt.

[[menu-button]]
=== Menü-Button

Ein Menü-Button, technisch Split-Button, ist eine Kombination aus einem <<button>> und einem <<dropdown,Dropdown>>.
Die linke Hälfte des Buttons löst beim Betätigen eine Standardaktion aus (zum Beispiel Speichern) und die rechte Hälfte öffnet eine Auswahl an Funktionen (zum Beispiel Speichern als PDF oder Speichern als XLS).

Diese Button-Art wird hauptsächlich in Toolbars eingesetzt und muss immer mehrere Funktionen, die in einen logischen Zusammenhang zueinander stehen, beinhalten.
Eine mögliche Verwendung ist das Zusammenfassen von mehreren Exportmöglichkeiten.

Menü-Buttons bestehen aus zwei Bestandteilen:

* einem <<icons,Icon>> beziehungsweise einem <<label>> oder einer Kombination von Icon und Label.
* einem Pfeil-Icon, das per Klick die Dropdown-Liste öffnet.

[[image-menuebuttonbeispiel]]
.Menü-Button
image::24_DP_Menue_Button.png[align="center"]

[TIP]
Das Icon sollte inhaltlich eindeutig zur Funktion passen.
Es sollten bereits bekannte Symbole (zum Beispiel Diskette = Speichern) genutzt werden.
Bei der Gestaltung sollte darauf geachtet werden, dass die Icon-Sprache über die gesamte Anwendung konsistent bleibt.

[[eingabefeldgruppen]]
=== Eingabefeldgruppen

In fast jedem Frontend beziehungsweise in den häufigsten Anwendungsfällen lassen sich Eingabefelder inhaltlich zu (homogenen) Gruppen zusammenfassen.
Häufig verwendete Gruppen sind beispielsweise „Angaben zur Person“ (mit den Eingabefeldern Vorname, Familienname, Nationalität, Geschlecht etc.), Adressdaten (Straße, Hausnummer, Postleitzahl, Ort) oder Bezahldaten (Art der Bezahlung, Kartennummer etc).
Eingabefeldgruppen sind eine Möglichkeit solche Gruppierungen darzustellen.

Eingabefeldgruppen bestehen immer aus mindestens einer Gruppenüberschrift beziehungsweise einem Gruppenlabel, mehreren <<eingabefeld,Eingabefeldern>> und gegebenenfalls weiteren <<bedienelemente,Bedienelementen>>. +
Dies lässt sich durch zwei Möglichkeiten realisieren: <<ueberschriften,Überschrift>> und <<bedienelemente>> oder Fieldset mit Bedienelementen.

*_Eingabefeldgruppe mit Überschrift und Bedienelement:_*

[[image-eingabefeldgruppe]]
.Eingabefeldgruppe Beispiel: Persönliche Angaben
image::24_DP_persoenliche_angaben.png[align="center"]

Es wird ein einspaltiges Layout verwendet.
Jedes Eingabefeld ist ein Pflichtfeld, gekennzeichnet durch einen Asterisk (*).
Eingabefeldgruppen bedürfen keiner zusätzlichen optischen Gruppierung.
Sie können durch ihre inhaltlich logische Struktur dem zu empfehlenden dreispaltigen Layout des Frontends (siehe <<image-vertikalerschnitt>>) folgen.

*_Eingabefeldgruppe mit Fieldset:_*

[[image-bedingtepflichtfeldgruppe]]
.Eingabefeldgruppe mit bedingten Pflichtfeldern
image::24_DP_bedingte_pflichtfeldgruppe.png[align="center"]

Bei einer bedingten Pflichtfeldgruppe (ehemals "optionale Pflichtfelder") ist das Ausfüllen mindestens eines Feldes in einer Eingabefeldgruppe Voraussetzung, um den Prozess abzuschließen.

.Identitätsnachweisdokument
====
Der Prozess sieht vor, dass ein Nachweis über die Identität erbracht wird.
Dies kann jedoch über verschiedene Dokumente erfolgen.
Somit wird unter der Gruppe „Identitätsnachweisdokument“ in verschiedenen Eingabefeldern die Möglichkeit gegeben sich für eine Nachweisart zu entscheiden und entsprechend ihrer Art entweder eine Auswahl zu treffen oder eine entsprechende Nummer anzugeben.

Dabei ist nicht das einzelne Eingabefeld ein Pflichtfeld, sondern das Ausfüllen mindestens einer Option innerhalb einer Eingabefeldgruppe verpflichtend.
Sobald eine Möglichkeit innerhalb der Gruppe ausgewählt bzw. befüllt wurde, wird die bedingte Pflichtfeldgruppe für den Identitätsnachweis als positiv bestätigt.
====

Für komplexere fachliche Konstellationen kann eine textuelle Hilfestellung mit Signalwörtern verwendet werden.
Der Einsatz solcher komplexen bedingten Pflichtfelder ist aus Sicht der Benutzerfreundlichkeit nur im *absoluten Ausnahmefall* zu wählen.
Vielmehr sollte überlegt werden, ob es einen verständlicheren fachlichen Lösungsansatz gibt.

*_Beispielhafte Verwendung von Gruppen und inhaltlich logische Gruppierung:_*

* Personendaten (rosa Overlay, vertikal gruppiert)
* Identitätsnachweis (oranger Overlay, vertikal gruppiert)

[[image-variationeingabefeldgruppen]]
.Verschiedene Eingabefeldgruppen vertikal gruppiert
image::24_DP_variation_eingabefeldgruppen.png[align="center"]

[[image-mehrspaltigegruppen]]
.Mehrspaltige inhaltliche Gruppe
image::24_DP_mehrspaltige_inhaltliche_Gruppe.png[align="center"]

Hier wird deutlich, dass in einem mehrspaltigen Layout verschiedene Kombinationen an Eingabefeldern in zweispaltiger (horizontaler) Anordnung einer Hauptgruppe (in Lila) unterliegen.
Die blockartige Anordnung erleichtert das Erfassen und ermöglicht eine thematische Untergruppen-Clusterung.

[[wertehilfen]]
=== Wertehilfen

Wertehilfen in Frontends sind interaktive Unterstützungselemente, die Benutzenden helfen, Formulare schneller und fehlerfrei auszufüllen.
Sie dienen dazu, die Eingabe durch vorgeschlagene oder vorausgewählte Werte zu erleichtern (zum Beispiel als <<datepicker-wertehilfe,Datepicker>>).

*_Anforderungen an Wertehilfen:_*

* *_Barrierefreiheit_*
** Tastaturzugänglichkeit: Wertehilfen müssen vollständig mit der Tastatur bedienbar sein, einschließlich <<navigation>>, Auswahl und Schließen.
** Screenreader-Unterstützung: Alle interaktiven Elemente müssen mit sinnvollen Labels versehen sein und korrekt angekündigt werden (zum Beispiel mittels <<aria-labels,aria-label>> oder aria-live-Regionen).
* *_Usability_*
** Intuitive Nutzung: Wertehilfen sollten verständlich gestaltet und optisch hervorgehoben werden, sobald sie aktiv sind.
** Fehlerminimierung: Eingabevalidierungen sollten Nutzenden bei ungültigen Werten direkt Hinweise geben.
* *_Responsive Design_*
** Wertehilfen müssen auf verschiedenen Bildschirmgrößen und bei Zoom (mindestens 200 %) einwandfrei funktionieren.

[NOTE]
Sollte eine barrierefreie Umsetzung der Wertehilfe nicht möglich sein, oder gar eine Barriere darstellen, so sollte diese vor assistiven Technologien verborgen werden und es muss eine (alternative) barrierefreie Tastatureingabe möglich sein.

*_Beispiele für Wertehilfen_*

* *_<<dropdown,Dropdowns:>>_*
** Zur Auswahl vordefinierter Werte, zum Beispiel aus einer Liste von Bundesländern.
* *_<<autosuggestion,Autovervollständigung:>>_*
** Nutzende geben Text ein, und die Anwendung schlägt passende Werte vor.
* *_<<datepicker-wertehilfe,Datumsauswahl:>>_*
** Ein Kalender-Widget unterstützt bei der Auswahl eines Datums.
* *_Zahlen-Spinner:_*
** Ermöglicht die Erhöhung oder Verringerung eines Wertes durch Pfeiltasten.

*_Dos:_*

* Hinweise bei ungültigen Eingaben direkt am Interaktionselement anzeigen.
* Inhalte und Beschriftungen so gestalten, dass sie klar und leicht verständlich sind.

*_Don'ts:_*

* Keine zwingende Nutzung von Werten aus der Hilfe, wenn eine manuelle Eingabe zulässig ist.
* Keine automatische Aktivierung von Wertehilfen, die ohne Nutzerinteraktion starten.

IMPORTANT: Die für die IsyFact gültigen Wertehilfen basieren auf PrimeNG-Komponenten.
Diese werden ständig weiterentwickelt und aktualisiert.
Dadurch können sie optisch von dem hier dokumentierten Stand abweichen.
Die folgenden Rahmenbedingungen müssen versionsunabhängig eingehalten werden.

[[datepicker-wertehilfe]]
==== Datepicker und Timepicker

[[image-datepicker-werte]]
.Beispiel eines Datepicker
image::24_DP_Datepicker-werte.png[align="center"]

*_Funktionalität:_* Ermöglicht die Auswahl eines Datums oder Zeitpunkts über ein interaktives Widget.

*_Bedienung:_*

* Maus: Klick auf das Eingabefeld öffnet den Kalender, ein weiterer Klick auf das gewünschte Datum wählt dieses aus.
* Tastatur: Tabulator zur Fokussierung, Pfeiltasten zur Navigation, Enter zur Auswahl.

*_Barrierefreiheit:_* Screenreader sollten die aktuelle Auswahl sowie Navigationsanweisungen klar ansagen.

[[inputnumber-wertehilfe]]
==== InputNumber

[[image-inputnumber-werte]]
.Beispiel eines InputNumber-Elements
image::24_DP_Inputnumber-werte.png[align="center"]

*_Funktionalität:_* Ermöglicht das Eingeben numerischer Werte mit optionalen Steuerelementen (zum Beispiel Pfeile).

*_Bedienung:_*

* Maus: Pfeilsymbole erhöhen oder verringern den Wert.
* Tastatur: Direkte Eingabe von Zahlen, Pfeiltasten zur Erhöhung/Verringerung.

*_Barrierefreiheit:_* Klare Beschriftungen und ARIA-Attribute für eine verständliche Ansage durch Screenreader.

[[cascadeselect-wertehilfe]]
==== CascadeSelect

[[image-cascadeselect-werte]]
.Beispiel eines CascadeSelect-Elements
image::24_DP_Cascadeselect-werte.png[align="center"]

*_Funktionalität:_* Bietet hierarchische Auswahlmöglichkeiten, die sich in Unterkategorien verzweigen.

*_Bedienung:_*

* Maus: Klick auf die oberste Kategorie öffnet die Unterkategorien.
* Tastatur: Navigation mit Tab und Pfeiltasten, Enter zur Auswahl.

*_Barrierefreiheit:_* Jede Ebene sollte korrekt fokussierbar sein, mit klaren Hinweisen auf Unterkategorien.

[[dropdown-wertehilfe]]
==== Dropdown

Genaue Details zur Umsetzung eines Dropdowns sind im Kapitel <<dropdown>> zu finden.

[[image-dropdown-werte]]
.Beispiel eines Dropdown-Elements
image::24_DP_Dropdown-werte.png[align="center"]

*_Funktionalität:_* Ermöglicht die Auswahl eines einzigen Wertes aus einer vordefinierten Liste.

*_Bedienung:_*

* Maus: Klick öffnet die Liste, ein weiterer Klick wählt den Eintrag.
* Tastatur: Tab zur Navigation, Pfeiltasten zur Auswahl, Enter zur Bestätigung.

*_Barrierefreiheit:_* Dropdown-Elemente müssen deutlich beschriftet sein, mit guter Unterstützung für Screenreader.

[[multiselect-wertehilfe]]
==== MultiSelect

[[image-multiselect-werte]]
.Beispiel eines MultiSelect-Elements
image::24_DP_Multiselect-werte.png[align="center"]

*_Funktionalität:_* Ermöglicht die Auswahl mehrerer Werte aus einer Liste.

*_Bedienung:_*

* Maus: Klick auf Kontrollkästchen oder Listenpunkte zur Mehrfachauswahl.
* Tastatur: Tabulator zur Fokussierung, Pfeiltasten zur Navigation, Space zur Auswahl.

*_Barrierefreiheit:_* Klarer Fokus und Ansagen für den Status (ausgewählt/nicht ausgewählt) bei Screenreadern.

[[context-Group-wertehilfe]]
==== Context Group

[[image-context-group-werte]]
.Beispiel einer Context Group
image::24_DP_Contextgroup-werte.png[align="center"]

*_Funktionalität:_* Ermöglicht das Hinzufügen oder Entfernen von kontextbezogenen gruppierten Eingabefeldern und Eingabemöglichkeiten (zum Beispiel "Wohnort", bestehend aus mehreren Adressinformationen).

*_Bedienung:_*

* Maus: Ein Klick auf "+ weiteres Element" erzeugt eine weitere Context Group und ein Klick auf Delete-Icon löscht die ausgewählte Context-Group.
* Tastatur: Tabulator zur Fokussierung, Pfeiltasten zur Navigation, Enter zur Auswahl.

*_Barrierefreiheit:_* Klarer Fokus und Ansagen für den Status (ausgewählt/nicht ausgewählt) bei Screenreadern.

[[selektion]]
=== Selektion

Selektionsmöglichkeiten in einem Frontend sind grundlegend bei der Bedienung eines Frontends notwendig.
Sie dienen zur Auswahl einzelner oder mehrerer Werte aus einer meist vordefinierten Menge.
Sie können beliebig kombiniert werden, um die Fehleranfälligkeit zu reduzieren und die Auswahlmöglichkeiten zu optimieren.

Eine Gruppe aus den folgenden Elementen bildet für die Selektion ein <<design-pattern>> und ist mit den aufgeführten Rahmenbedingungen einzusetzen.
Die genauen Definitionen und Umsetzung der einzelnen Elemente sind im entsprechenden Unterkapitel des Kapitels <<bedienelemente>> einzusehen.

[[checkbox-selektion]]
==== Checkbox

*_Funktionalität:_* Erlaubt die Auswahl mehrerer unabhängiger Optionen.

*_Best Practices:_*

* Klarer visueller Fokus bei Navigation mit der Tastatur.
* Zustände (aktiviert, deaktiviert, teilweise ausgewählt) müssen durch Screenreader korrekt angesagt werden.
* Mindestkontrast von 4,5:1 für alle Zustände (inklusive Hover und Fokus).

*_Barrierefreiheit:_*

* Nutzung von aria-checked und <<aria-labels,aria-label>> zur Beschreibung.
* Gruppierung ähnlicher <<checkbox,Checkboxen>> mit fieldset und legend.
* Click-Target-Area ist mindestens 44x44 Pixel.

[[radiobutton-selektion]]
==== Radiobutton

*_Funktionalität:_* Erlaubt die Auswahl einer einzigen Option aus einer Gruppe.

*_Best Practices:_*

* <<radiobutton,Radiobuttons>> sollten immer beschriftet und in logischer Reihenfolge angeordnet sein.
* Fokus- und Hover-Stile müssen klar erkennbar sein.

*_Barrierefreiheit:_*

* Verwendung von `role="radiogroup"` für zusammengehörige Optionen.
* Klare Statusmeldung wie "ausgewählt" über Screenreader.
* Click-Target-Area ist mindestens 44x44 Pixel.

[[dropdown-selektion]]
==== Dropdown

*_Funktionalität:_* Bietet eine kompakte Möglichkeit zur Auswahl eines Wertes aus einer Liste.

*_Best Practices:_*

* <<dropdown,Dropdowns>> sollten sich mit der Tastatur öffnen, navigieren und schließen lassen.
* Keine automatische Auswahl beim Öffnen; Nutzende müssen die Auswahl explizit bestätigen.

*_Barrierefreiheit:_*

* Nutzung von aria-expanded und aria-haspopup zur Kommunikation des Zustands.
* Liste muss tastaturzugänglich sein, und der Fokus sollte nicht verloren gehen.

[[multiselct-selektion]]
==== MultiSelect

*_Funktionalität:_* Erlaubt die Auswahl mehrerer Werte aus einer Liste.

*_Best Practices:_*

* Ausgewählte Elemente sollten visuell hervorgehoben werden.
* Klarer Hinweis, wenn die maximale Auswahlanzahl erreicht ist.

*_Barrierefreiheit:_*

* Verwendung von aria-selected zur Kennzeichnung ausgewählter Elemente.
* Unterstützung von Tastenkombinationen für das schnelle Auswählen/Deselektieren.

[[filter-selektion]]
==== Filter

*_Funktionalität:_* Ermöglicht das Eingrenzen von Datenmengen anhand vordefinierter Kriterien (zum Beispiel Kategorien, Preisbereiche).

*_Best Practices:_*

* Logische Gruppierung: Filteroptionen sollten thematisch gruppiert und leicht zugänglich sein.
* Interaktivität: Änderungen an Filtereinstellungen sollten das Ergebnis direkt aktualisieren (zum Beispiel durch Live-Aktualisierung).

*_Barrierefreiheit:_*

* Filterkomponenten sollten mittels fieldset und legend strukturiert sein.
* Klarer visueller Fokus und hörbare Rückmeldungen für Screenreader bei Änderungen.

[[suche-selektion]]
==== Suche

*_Funktionalität:_* Ermöglicht das gezielte Finden von Inhalte oder Daten innerhalb einer Anwendung.

*_Best Practices:_*

* Eingabefeld: Sollte klar beschriftet und mit einer <<autosuggestion,Autovervollständigungsfunktion>> ausgestattet sein, falls sinnvoll.
* Filterbare Ergebnisse: Die Suchergebnisse sollten weiter eingegrenzt werden können (zum Beispiel durch zusätzliche <<filter-selektion,Filteroptionen>>).

*_Barrierefreiheit:_*

* Einsatz von aria-live für dynamische Ergebnislisten.
* Sicherstellung, dass Screenreader alle Interaktionen klar kommunizieren (zum Beispiel „X Ergebnisse gefunden“).

*_Integration von Suche und Filter_*

* Die Kombination aus Such- und Filterfunktionen erhöht die Effizienz bei der Navigation durch große Datenmengen.
* Alle Interaktionen müssen tastaturzugänglich und in dynamischen Kontexten (aria-live) barrierefrei implementiert werden.
* Sicherstellung, dass Filtereinstellungen beim Verlassen der Seite erhalten bleiben, sofern es sinnvoll ist.

[[browse-and-collect]]
==== Browse & Collect

In der IsyFact wird als Basis das PrimeNG Widget "PickList" genutzt.

*_Funktionalität:_* Die Browse & Collect-Funktion ermöglicht es Benutzenden, durch umfangreiche Inhalte zu navigieren und dabei relevante Elemente zu markieren oder in eine Sammlung aufzunehmen.
Dies wird häufig in Kontexten genutzt, in denen eine Auswahl von Daten für spätere Aktionen erforderlich ist (zum Beispiel Warenkorb, Favoritenliste).

*_Best Practices:_*

* Übersichtliche Navigation: Inhalte sollten logisch gegliedert und mit <<filter-selektion,Filter>>-, <<suche-selektion,Such>>- und <<selektion,Selektionsmöglichkeiten>> kombinierbar sein.
* Markierung und <<system-meldungen,Rückmeldung>>: Markierte Elemente sollten visuell hervorgehoben und durch dynamische Hinweise (zum Beispiel Toast-Benachrichtigungen) bestätigt werden.
* Sammlung bearbeiten: Benutzende müssen die Möglichkeit haben, gesammelte Elemente zu überprüfen, zu ändern oder zu entfernen.

*_Barrierefreiheit:_*

* Tastaturbedienung: Alle Aktionen müssen mit der Tastatur steuerbar sein, zum Beispiel durch Tab- und Enter-Tasten oder spezifische Pfeiltasten-Navigation.
* Screenreader-Unterstützung: Markierte Elemente und deren Status müssen eindeutig angesagt werden.
* Visuelle Kontraste: Hervorgehobene und markierte Elemente sollten mindestens ein Kontrastverhältnis von 4,5:1 erfüllen.

*_Beispielanwendung:_* Durchstöbern eines digitalen Archivs mit der Möglichkeit, relevante Dokumente zu markieren und später als PDF herunterzuladen.

Diese Funktionalität verbessert die Benutzerfreundlichkeit in datenintensiven Anwendungen und stellt sicher, dass alle Interaktionen den Anforderungen an <<barrierefreiheit,Barrierefreiheit>> und Benutzererlebnis gerecht werden.

Alle Selektionskomponenten müssen die Anforderungen an Barrierefreiheit und Nutzerfreundlichkeit erfüllen, einschließlich:

* Tastaturzugänglichkeit für alle Funktionen.
* Screenreader-Kompatibilität durch semantische ARIA-Attribute.
* Visuelle Klarheit durch hohe Kontraste und verständliche Beschriftungen.

[[output]]
=== Ausgabe

[[output-via-table]]
==== Datenausgabe mit Tabellen

Zur strukturierten Darstellung von vielen Daten bietet es sich an <<tabelle,Tabellen>> zu nutzen.
Bei der Nutzung von Tabellen sind in der IsyFact über die grundsätzlich zur Tabelle geltenden Regeln folgende Richtlinien zu berücksichtigen:

* Klare Struktur: Überschriften müssen mit semantischen Tags (<th>) ausgezeichnet sein, um die Bedeutung der Inhalte zu verdeutlichen.
* Responsives Design: Tabellen sollen sich an verschiedene Bildschirmgrößen anpassen und bei Platzmangel scrollbar sein.
* Barrierefreiheit: Screenreader-Unterstützung durch ARIA-Attribute wie aria-labelledby und klare Fokusführung bei der Navigation.
* Interaktivität: Sortier-, Filter- und Exportmöglichkeiten, die über Tastatur und Maus zugänglich sind.

Tabellen fördern die effiziente Verarbeitung und Analyse umfangreicher Datenmengen.
Für eine bestmögliche Verwendung in den verschiedensten Anwendungen der IsyFact ist es ratsam ein einheitliches Pattern zu berücksichtigen.
Tabelleneinträge können mit der Maus und Tastatur ausgewählt werden und mit Klick oder Enter zur Ansicht/Bearbeitung geöffnet werden.
Optional ist es mögliche eine „adhoc“- Detailansicht unterhalb der Tabelle einzusetzen, diese ist vom Fachbereich individuell zu definieren.
Weiterführende Aktionen, wie zum Beispiel Schnellbearbeitung, Drucken, Download oder Löschen, sind in der Aktionsleiste unterzubringen.
Durch die vielen verschiedenen fachlichen Ansprüche ist es nicht möglich und sinnvoll alle Ausprägungen an weiterführenden Aktionen abzubilden und vorzudefinieren.
Die häufig genutzten Aktionen, wie Schnellbearbeitung (<<editable-row-output,editable Row>>), Drucken, Download und Löschen, sollten über alle Anwendungen hinweg einheitlich genutzt werden.

[[editable-row-output]]
==== Schnellbearbeitung in Tabellen

Schnellbearbeitung (Editable Row) ermöglicht das direkte Bearbeiten von Daten innerhalb einer Tabellenzeile.

*_Funktionalität:_* Ermöglicht das direkte Bearbeiten von Daten innerhalb einer Tabellenzeile.
Dies verbessert die Effizienz, da Benutzende nicht zwischen Ansichts- und Bearbeitungsmodi wechseln müssen.

*_Bedienung:_* Durch einen Klick auf "Bearbeiten" wird eine Zeile in den Bearbeitungsmodus versetzt, und Eingabefelder werden aktiviert.
Änderungen können direkt gespeichert oder verworfen werden.

*_Barrierefreiheit:_*

* Fokussierung aller interaktiven Elemente innerhalb der Zeile per Tabulator.
* Klare visuelle und sprachliche <<system-meldungen,Rückmeldungen>> bei Aktionen (zum Beispiel „Änderung gespeichert“).
* Beschriftungen und ARIA-Attribute für Screenreader.

Diese Funktionalität fördert eine intuitive und zugängliche Datenbearbeitung.

[[print-output]]
==== Drucken

Drucken ermöglicht das direkte Drucken von Daten der Tabellenzeile.
Dabei können nicht nur die aus der Tabelle angezeigten Daten gedrückt werden, sondern je nach Funktionalität auch weiterführende Daten aus einer optionalen Detailansicht.

*_Funktionalität:_* Durch einen Klick oder eine Tastaturinteraktion wird eine Zeile mit optional weiterführenden Daten ausgedruckt (die Druckvorschau des Browsers wird geöffnet).

*_Barrierefreiheit:_* Beschriftungen und ARIA-Attribute für Screenreader.

[[export-output]]
==== Exportieren

Exportieren ermöglicht die Überführung eines Datensatzes in ein gewünschtes Zielformat oder Programm.

*_Funktionalität:_* Durch einen Klick oder eine Tastaturinteraktion wird eine Zeile in das vordefinierte Format der Anwendung exportiert.

*_Barrierefreiheit:_* Beschriftungen und ARIA-Attribute für Screenreader.

[[delete-output]]
==== Löschen

*_Funktionalität:_* Ermöglicht das direkte Löschen einer gesamten Tabellenzeile.
Dies verbessert die Effizienz, da Benutzende nicht zwischen Ansichts- und Bearbeitungsmodi wechseln müssen.

*_Bedienung:_* Durch einen Klick oder eine Tastaturinteraktion wird eine Zeile gelöscht.
Zur Vermeidung von versehentlichen Aktionen sollte die Löschfunktion zusätzlich über einen modalen Dialog (zum Beispiel: "Sind Sie sich sicher, diesen Datensatz zu löschen?" "Ja/Nein") abgesichert werden.

*_ Barrierefreiheit:_*

* Klare visuelle und sprachliche <<system-meldungen,Rückmeldungen>> bei Aktionen (zum Beispiel „Datensatz gelöscht“).
* Beschriftungen und ARIA-Attribute für Screenreader.


[[Stepper]]
=== Stepper/Wizard

*WiP*

[[use-cases]]
== Use Cases

Use Cases stellen typische Szenarien oder Seiten dar, die bestimmte Funktionalitäten oder Aktionen erfordern.
Dieser Abschnitt kombiniert <<design-pattern,Design Patterns>>, um benutzerfreundliche Lösungen für spezifische Anwendungsfälle zu präsentieren und ihre Umsetzung anhand von Beispiel-Screens zu veranschaulichen.

[[formulare]]
=== Formulare

Inhalte von Formularen sollten sich an einem virtuellen, nicht visuell dargestellten Raster ausrichten.
Formulare sollen einem einspaltigen, zweispaltigen oder dreispaltigen Layout folgen.
Dabei sind alle Spalten innerhalb eines Formulars gleich breit aufgebaut.

*_Beispielhaftes Formular dreispaltig:_*

[[image-dreispaltenlayout]]
.Drei-Spalten Layout
image::24_UC_3_spalten.png[align="center"]

Formulare bestehen mindestens aus einer <<eingabefeldgruppen,Eingabefeldgruppe>> und einer beliebigen Anzahl weiterer Elemente.
Alle Regeln für <<eingabefeld,Eingabefelder>> und <<label>> haben hier auch ihre Gültigkeit.

Die inhaltliche Gruppierung folgt dabei keinem starren Muster, sondern kann fachlich entsprechend angepasst werden.
Diese Gruppierung der Inhalte kann dabei sowohl horizontal als auch vertikal gestaltet werden.
Hierbei ist wichtig, dass die Inhaltselemente über eine Gruppenüberschrift logisch zusammengefasst werden.

*_Exemplarische inhaltliche Nutzung der Spalten:_*

[[image-vertikalerschnitt]]
.Drei-Spalten Layout mit unterschiedlich breiten inhaltlichen Gruppen
image::24_UC_vertikaler_schnitt.png[align="center"]

Durch die saubere Anwendung der Gruppenüberschriften, Titel und Eingabefeldgruppen ist auch ein Wechsel der vertikalen Gruppierungsgröße nicht negativ auffällig.
Jede inhaltliche Gruppe (dreispaltig in der ersten Gruppe (rosa, orange, gelb) und einspaltig in der nächsten Gruppe (grün)) wird ganzheitlich als logisches Element wahrgenommen.

*_Wahrnehmung der inhaltlichen Gruppen:_*

[[image-wahrnehmunghorizontalegruppe]]
.Wahrnehmung der inhaltlichen Gruppen Hierarchie
image::24_UC_horizontale_inhaltlichte_gruppe.png[align="center"]

Gleichmäßige Feldlängen unterstützen den Lesefluss der Nutzenden.
Die letzten Eingabefelder können bei Bedarf ihrem Inhalt entsprechend gekürzt werden.
Dies unterstützt die inhaltlich logische Gruppierung und signalisiert den Nutzenden auch visuell ein Ende der inhaltlichen Gruppe.

Bei geringeren Auflösungen sollten Eingabefelder untereinander angeordnet werden, um sich der begrenzten Breite anzupassen.

Die Größenanpassung erfolgt innerhalb von gewissen Bereichen:

* Wird das Browserfenster kleiner als der darzustellende Inhalt (in der Regel bei Tablets und Smartphones), so wird das gesamte Fenster vertikal scrollbar.
* Der vertikale Abstand zwischen Gruppen und Eingabefeldern bleibt unabhängig von der Bildschirmgröße konstant.
* Der Abstand zwischen Eingabefeldern und Labeln bleibt ebenfalls unverändert.
* Bei einer Veränderung der Browserfenster-Größe sollte sich die Breite der Spalten dynamisch an den verfügbaren Platz anpassen, ohne dabei die Lesbarkeit zu beeinträchtigen.

*_Beispielhafte Gesamtumsetzung eines Formulars im Anwendungsrahmen:_*

[[image-beispielgesamtumsetzung]]
.Beispielhafte Gesamtumsetzung eines Beispielformulars im Anwendungsrahmen
image::24_UC_fullexample_formular.png[align="center"]

[[login]]
=== Login

*WiP*

[[objekt-suche]]
=== Objekt suchen

*WiP*

[[objekt-anzeigen]]
=== Objekt anzeigen

*WiP*

[[objekt-beabeiten]]
=== Objekt bearbeiten

*WiP*

[[objekt-loeschen]]
=== Objekt löschen

*WiP*

[[objekt-neu-anlegen]]
=== Objekt neu anlegen

*WiP*

[[eingabehilfen-und-fehlermeldungen]]
== Eingabehilfen und Fehlermeldungen

Eingabehilfen und Fehlermeldungen sind essenziell wichtig, um die <<usability-und-benutzerfreundlichkeit,Benutzerfreundlichkeit>> eines Frontends zu erhöhen.
Im folgenden Kapitel werden die Grundlagen zur erfolgreichen Gestaltung von Eingabehilfen und Fehlermeldungen erläutert.

[[eingabehilfen]]
=== Eingabehilfen

[[gute-labels]]
==== Korrekte Labels

Auch <<label,Labels>> gelten als Eingabehilfen.
Klare und präzise Beschriftungen (Labels) sind für die Benutzerführung entscheidend, insbesondere für <<formulare>> und <<eingabefeld,Eingabefelder>>.
Jedes Eingabefeld muss ein entsprechendes Label haben, das den Nutzenden genau sagt, welche Art von Information erwartet wird.
Beispielsweise sollte ein Anmeldeformular separate Felder für "Anmeldename" und "Passwort" haben, jeweils mit deutlich sichtbaren Labels.

[[placeholder]]
==== Gute Platzhaltertexte

Platzhaltertexte sind nützlich, um Nutzenden zusätzliche Hinweise oder Beispiele für die erwarteten Eingaben zu geben.
Sie sollten jedoch nicht als Ersatz für <<label,Labels>> dienen.
Idealerweise sollten Platzhaltertexte kurz und prägnant sein, um den Nutzenden zu helfen, die Anforderungen des jeweiligen <<eingabefeld,Eingabefelds>> besser zu verstehen, ohne den Platz zu überladen oder den Fokus zu stören.

*_Beispiel 1:_*
Es wird ein Nachname im Eingabefeld erwartet

*Do:*
Nachname

*Don't:*
Dein Nachname

*_Beispiel 2:_*
Es wird eine Telefonnummer erwartet

*Do:*
+49 123 1234567

*Don't:*
Deine Telefon- oder Handynummer

Sobald die Nutzenden in das Eingabefeld klicken, wird der Platzhalter ausgeblendet und es besteht die Möglichkeit, eine Mask anzeigen zu lassen (siehe Kapitel <<eingabefeld,Eingabefelder>>).
Sie geben das gewünschte Eingabepattern vor und lassen sich fast vollständig frei gestalten.

*_Gute Hinweistexte zur Erläuterung bei Eingabefeldern und Fehlermeldungen:_*

Bei komplexeren <<formulare,Formularen>> oder spezifischen Eingabeanforderungen können Hinweistexte hilfreich sein, um den Nutzenden zusätzliche Anleitungen oder Kontext zu bieten.
Diese Texte sollten in der Nähe des entsprechenden Eingabefelds platziert werden und sollten klar und präzise sein.
Sie können beispielsweise erklären, welche Art von Informationen erwartet wird oder auf spezielle Formatierungsanforderungen hinweisen.

[[autosuggestion]]
==== Autosuggestion

Autosuggestion ist eine Zusatzfunktion, die in <<eingabefeld,Eingabefeldern>> ergänzt werden kann.
Sie dient dazu, Eingaben durch Vorschläge zu vervollständigen und somit zu beschleunigen.
Diese Eingabehilfe erscheint direkt unter dem Textfeld.
Sie schließt sich, wenn Nutzende neben die Eingabehilfe klicken oder innerhalb der Eingabehilfe ihre Auswahl treffen.

[[image-autosuggestion]]
.Darstellung einer funktionalen Autosuggestion
image::24_EF_autosuggestion.png[align="center"]

Sobald die Nutzenden mit der Eingabe beginnen, werden mögliche Werte, die mit der getätigten Eingabe beginnen, in einem Menü unterhalb des Textfelds angezeigt.
Nutzende können nun weiter tippen oder direkt einen Wert aus dem Menü auswählen und somit ihre Eingabe verkürzen.
Gibt es mehr als zehn mögliche passende Werte, so werden die ersten zehn Werte angezeigt, gefolgt von einer Information, dass mehr als zehn Einträge existieren.

[[fortschrittsanzeige]]
==== Fortschrittsanzeige

Feedback-Konzepte für Ladezeiten sind ein sehr wichtiges Instrument, um eine gute User Experience zu erreichen.
Für längere Operationen kann ein Fortschritts-Balken (Progress Bar) genutzt werden, der sich entsprechend dem Fortschritt des Vorgangs füllt.
Für kürzere Vorgänge kann ein Fortschritts-Spinner (kreisrunde Fortschrittsanzeige) verwendet werden.

[[image-spinnerbar]]
.Spinner und Progressbar
image::24_EF_spinner_and_bar.png[align="center"]

[[image-spinnerbarlist]]
.Spinner in einer Liste angewandt
image::24_EF_spinner_and_bar_in_list.png[align="center"]

*_Grundlegende Anwendungshinweise:_*

* Generell sollten Vorgänge oder Operationen, die mehr als eine Sekunde in Anspruch nehmen, eine Rückmeldung in Form einer Fortschrittsanzeige an Nutzende geben.
* Die Form der Fortschrittsanzeige richtet sich dabei nach der Länge des Vorgangs und dem Anwendungskontext.
* Fortschrittsanzeigen werden in der Regel nur für Wartezeiten verwendet, die sich aus System-Operationen ergeben.
Für Wartezeiten, die sich auf die Bedienung der Nutzenden zurückführen lassen, werden keine Fortschrittsanzeigen eingesetzt.

*_Fortschritts-Balken (Progress Bar):_*

* Fortschritts-Balken werden in der Regel für Ladevorgänge mit bestimmbarer Gesamtlänge verwendet.
* Ein Balken zeigt den Grad der Zielerreichung an.
Dabei füllt sich der Balken von links (0 %) nach rechts (100 %).

*_Fortschritts-Spinner (kreisrunde Fortschrittsanzeige):_*

* Fortschritts-Spinner werden für Ladevorgänge verwendet, deren Gesamtlänge unbekannt ist.
* Für die Dauer der Operation dreht sich der Fortschritts-Spinner und signalisiert Nutzenden damit, dass sich ein Prozess in Gang befindet.
Der Fortschritts-Spinner empfiehlt sich aufgrund seiner geringen Maße insbesondere in Situationen, in denen Platzbedarf von großer Bedeutung ist.

[[system-meldungen]]
==== System-Meldungen

Beim Verfassen von System-Benachrichtigungen – wie beispielsweise <<fehlermeldungen>> – muss auf eine verständliche und konsistente Formulierung geachtet werden.
Neben <<image-eingabefelderror,Fehlermeldungen, die am Eingabeobjekt auftreten>>, kann zusätzlich ein zusammenfassender Hinweis angezeigt werden (*Achtung:* dynamisch nachgeladene Elemente müssen auch einem Screenreader mitgeteilt werden, sodass auch Personen mit Einschränkungen diese Hinweise mitbekommen).
Dies geschieht mithilfe von Toast-Notifications, welche immer am unteren rechten Rand des Browserfensters angezeigt werden.

Jede Toast-Notification muss eine Schließen-Aktion für den Nutzenden anbieten.
Um die <<barrierefreiheit>> einzuhalten, muss die Notification dauerhaft eingeblendet bleiben, bis sie von den Nutzenden geschlossen wird, siehe https://www.w3.org/WAI/WCAG21/Understanding/content-on-hover-or-focus.html[WCAG 2.1 Kriterium 1.4.13a].

Folgende Meldungsarten können als Toast-Notification verwendet werden:

* Warnung
* Hinweis
* Fehler
* Erfolg

[[image-toastnotification]]
.Verschiedene Toast-Notifications
image::24_UC_toast_notification.png[align="center"]

*_Hinweisdialoge und -popups_* WiP

*_Dos_*

* *Allgemeinverständliche und positive Sprache*
** _Inkorrekt_:
„Soll das Objekt gelöscht werden?“
** _Besser_:
„Wollen Sie das gewählte Objekt XY löschen?“
* Verwenden einer einfachen und konsistenten Satzstruktur
* *Präzise Formulierungen*:
** _Inkorrekt_:
„Nichts selektiert“
** _Besser_:
„Bitte selektieren Sie ein Objekt in der Liste“
* *Positive Formulierungen*:
** _Inkorrekt_:
„Illegale String-Länge aufgetreten.“
** _Besser_:
„Es wurden zu viele Zeichen eingegeben.
Es sind maximal 20 Zeichen möglich.“
* Es soll nicht nur das Problem geschildert, sondern auch eine mögliche Lösung mitgeliefert werden.

*_Don'ts_*

* Vermeidung von redundanten Informationen
* Vermeidung von mehrdeutigen Beschreibungen

[[fehlermeldungen]]
=== Fehlermeldungen

Fehlermeldungen sind unvermeidlich, aber wie sie präsentiert werden, kann einen großen Unterschied für die Benutzererfahrung bedeuten.
Fehlermeldungen sollten gut sichtbar und in verständlicher Sprache verfasst sein sowie klare Anweisungen zur Behebung des Fehlers enthalten.
Idealerweise sollten Fehlermeldungen in unmittelbarer Nähe von betroffenen Objekten platziert werden (siehe als Beispiel: <<image-eingabefelderror,Eingabefelder - Fehlermeldung>>), um Nutzenden sofortiges Feedback zu geben und sie bei der Fehlerbehebung zu unterstützen.
Neben Fehlermeldungen, die am Eingabeobjekt auftreten, kann zusätzlich ein zusammenfassender Hinweis, wie im Kapitel <<system-meldungen>> beschrieben, angezeigt werden.

Ein häufig gemachter Fehler ist dabei die Verwendung von negativ anmutenden Formulierungen, die Benutzende demotivieren können.
Die folgende Liste zeigt einige negative Bezeichnungen und ihre neutralen Äquivalente:

[cols="5a,5a", options="header", align="center"]
|====
|Negativer Begriff |Neutraler Begriff

|Illegal
|Nicht korrekt

|Fehler
|Problem

|Fehlschlagen („Speichern ist fehlgeschlagen“)
|Nicht können („Es konnte nicht gespeichert werden“)
|====

[[designrichtlinien]]
== Designrichtlinien

*WiP*

[[Screenareas]]
=== Screenbereiche (Screenareas)

*WiP* (beinhaltet die Grundstruktur einer Frontend-Seite anhand der isy-angular-widgets Komponente isy-hauptfenster)

[[Header]]
==== Header

*WiP* (beinhaltet die Hauptnavigation des isy-hauptfensters)

[[Contentarea]]
==== Contentbereich (Contentarea)

*WiP*

*_Content only (Fullsize)_* *WiP*

*_Content mit Sidebar_* *WiP* (beinhaltet die Linksnavigation und den Informationsbereich des isy-hauptfensters)

[[Footer]]
==== Footer

*WiP*

[[modale-dialoge]]
=== Umgang mit modalen Dialogen

*WiP*

[[readonly-vs-disabled]]
=== Readonly vs. Disabled

<<readonlystate,Readonly>> und<<disabledstate,Disabled>> Zustände habe klar definierte Unterschiede, die gezielt genutzt werden können.

[[readonlystate]]
==== "Readonly" State

Ein "Readonly"-Feld erlaubt es, die darin enthaltenen Daten zu sehen, jedoch nicht zu ändern.
Dies ist besonders dann nützlich, wenn Informationen relevant sind, jedoch nicht modifiziert werden sollen.

*_Merkmale:_*

* *Sichtbarkeit:* Der Inhalt des Feldes kann von Nutzenden vollständig gesehen und von Screenreadern erfasst werden.
* *Interaktivität:* Die Daten können nicht bearbeitet werden, jedoch bleiben Funktionen wie das Markieren und Kopieren erhalten.
* *Design:* Optisch wird das <<image-eingabefeldreadonly,Eingabefeld>> leicht modifiziert mit leichteren Farben oder Formen dargestellt.

*_Anwendungsfälle:_*

* *Bestätigungsseiten:* Nach der Eingabe eines Formulars kann ein "Readonly"-Zustand verwendet werden, um die eingegebenen Daten zur Überprüfung anzuzeigen.
* *Informationsanzeige:* Felder, die wichtige Daten enthalten, die jedoch von bestimmten Nutzergruppen nicht verändert werden sollen (zum Beispiel automatisch generierte ID-Nummern, erfasste Zeitstempel).

*_Handlungsempfehlungen:_*

"Readonly" sollte für Felder verwendet werden, deren Inhalte für Nutzende relevant sind, aber nicht verändert werden dürfen.
Gestalte das Design so, dass die visuelle Unterscheidung klar, aber nicht störend ist – zum Beispiel durch subtile Farbveränderungen.
Erlaube Nutzenden weiterhin Inhalte aus dem "Readonly"-Feld zu kopieren.

[[disabledstate]]
==== "Disabled" State

Ein "Disabled"-Feld hingegen ist vollständig inaktiv.
Nutzende können den Inhalt nicht oder schlecht sehen, nicht bearbeiten und auch keine Interaktion (wie Kopieren) durchführen.
Diese Option wird verwendet, um Nutzenden zu signalisieren, dass bestimmte Funktionen oder Eingaben derzeit nicht zur Verfügung stehen.

*_Merkmale:_*

* *Sichtbarkeit:* Oft wird der Inhalt des Feldes ausgegraut oder gar nicht sichtbar gemacht.
* *Interaktivität:* Keine Interaktion möglich – weder das Bearbeiten, noch das Kopieren von Inhalten.
* *Design:* Meist visuell hervorgehoben durch ausgegraute Felder oder abweichende Farbschemata, um den Zustand klar zu kommunizieren.

*_Anwendungsfälle:_*

* *Zugriffssteuerung:* Felder, die nur von Nutzergruppen mit bestimmten Rechten bearbeitet werden dürfen, können für andere "disabled" sein.
* *Bedingte Formularfelder:* Wenn bestimmte Eingaben erst aktiviert werden sollen, nachdem vorherige Felder korrekt ausgefüllt wurden, können diese initial "disabled" sein.

*_Handlungsempfehlungen:_*

"Disabled" sollte für Felder verwendet werden, die Nutzenden derzeit nicht zugänglich sein sollen, um Fehlinteraktionen zu verhindern.
Vermeide "Disabled" für wichtige Informationen, die Nutzende sehen müssen – in solchen Fällen ist "Readonly" besser geeignet.
Mache den "Disabled"-Status klar ersichtlich, indem eine deutliche visuelle Abgrenzung durch Ausgrauen oder andere farbliche Mittel verwendet wird.

*_Vergleich und Fazit_*

Der wesentliche Unterschied zwischen "Readonly" und "Disabled" liegt in der Sichtbarkeit und der Interaktivität der Felder.
Während "Readonly"-Felder Nutzenden Informationen präsentieren, die sie nicht bearbeiten dürfen, aber weiterhin sehen und kopieren können, sind "Disabled"-Felder vollständig gesperrt und weder sichtbar noch interaktiv.
Für die Anwendung in Formularen sollten folgende Grundsätze beachtet werden:

* "Readonly" ist ideal, wenn die Informationen wichtig sind und für Nutzende sichtbar bleiben müssen, aber nicht verändert werden sollen.
* "Disabled" eignet sich, wenn Nutzende keine Informationen im Feld sehen oder bearbeiten sollen – zum Beispiel bei unzugänglichen Funktionen oder Bedingungen, die erst später erfüllt werden müssen.

[[panel-akkordeon-ueberschrift]]
=== Panel vs. Akkordeon vs. Überschrift

Allein aus der Beschreibung der einzelnen Elemente, <<panel>>, <<akkordeon>> und <<ueberschriften,Überschrift>>, lässt sich eine konkrete und präferierte Anwendung der einzelnen Elemente ableiten.
Alle Elemente erfüllen ihren eigenen Zweck.
Auffällig ist jedoch die sehr ähnliche Gestaltung des Akkordeons und des Panels.
Dies liegt an der historischen Annäherung der Elemente.
Für Nutzende ist eine solch differenzierte Betrachtung auf die technischen Elemente in den meisten Fällen nicht möglich und auch nicht notwendig, weshalb auf eine optische und historisch gewachsene minimale Differenzierung der beiden Elemente zu Gunsten der Usability verzichtet werden kann.

Alle drei Elemente werden zur Strukturierung von Frontends und deren Inhalte benötigt.

*_Elemente:_*

* Überschriften sind aus Sicht der Barrierefreiheit mindestens in erster Ebene notwendig und sollten zur Strukturierung des Frontends genutzt werden.
* Akkordeons sollten für lange und rein informative Inhalte genutzt werden (zum Beispiel FAQ-Bereich).
* Panels sollten für lange und komplexe interaktive Inhalte genutzt werden (zum Beispiel <<formulare>>).

*_Übergeordnete Verwendung:_*

Eine Frontend-Page sollte mindestens eine Überschrift (`h1`) enthalten und nur einen Widget-Typ nutzen (Akkordeon oder Panel).
Eine Vermengung beider Elemente soll vermieden werden, da unterschiedliches Verhalten optisch ähnlicher Elemente Verwirrung bei Nutzenden herbeiführt.

Zur Vereinfachung der Usability wird empfohlen, die <<akkordeon>> und <<panel>> optisch anzunähern.
Beide Elemente sollten sich über das gleiche Symbol aus- und einklappen lassen.
